========================================================================================================================================================================================
С
========================================================================================================================================================================================
main.c
========================================================================================================================================================================================
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include "stack.h" // Подключение заголовочного файла для работы со стеком
#include "set.h" // Подключение заголовочного файла для работы с множеством
#include "queue.h" // Подключение заголовочного файла для работы с очередью
#include "table.h" // Подключение заголовочного файла для работы с хеш-таблицей
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#pragma comment(lib, "ws2_32.lib")
#define PORT 6379 // Определение порта для сервера
#define BACKLOG 10 // Определение максимального количества ожидающих подключений
#define BUFFER_SIZE 104857600 // Определение размера буфера

HANDLE mutex; // Объявление мьютекса
DWORD WINAPI handle_client(LPVOID lpParam); // Объявление функции обработки клиента

int main() {
    WSADATA wsa_data;
    int result = WSAStartup(MAKEWORD(2, 2), &wsa_data); // Инициализация библиотеки сокетов
    SOCKET listen_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // Создание сокета для прослушивания
    struct sockaddr_in server_address; // Структура для хранения адреса сервера
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = htonl(INADDR_ANY);
    server_address.sin_port = htons(PORT);
    result = bind(listen_socket, (struct sockaddr*)&server_address, sizeof(server_address)); // Привязка сокета к адресу
    result = listen(listen_socket, BACKLOG); // Начало прослушивания сокета
    printf("The server is running and waiting for connections on port %d\n", PORT);
    mutex = CreateMutex(NULL, FALSE, NULL); // Создание мьютекса
    while (1) {
        SOCKET client_socket = accept(listen_socket, NULL, NULL); // Принятие подключения от клиента
        CreateThread(NULL, 0, handle_client, (LPVOID)client_socket, 0, NULL); // Создание потока для обработки клиента
    }
    closesocket(listen_socket); // Закрытие сокета прослушивания
    WSACleanup(); // Очистка библиотеки сокетов
    return 0;
}

DWORD WINAPI handle_client(LPVOID lpParam) {
    WaitForSingleObject(mutex, INFINITE); // Получение мьютекса
    SOCKET client_socket = (SOCKET)lpParam; // Получение сокета клиента
    char* buffer = (char*)malloc(BUFFER_SIZE * sizeof(char)); // Выделение памяти под буфер
    int bytes_received;
    bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0); // Получение данных от клиента
    buffer[bytes_received] = '\0';
    char** argv = NULL;
    int argc = 0;
    char* token = strtok(buffer, " "); // Разбиение полученных данных на токены
    while (token != NULL) {
        char** temp = realloc(argv, sizeof(char*) * (argc + 1));
        argv = temp;
        argv[argc++] = token;
        token = strtok(NULL, " ");
    }
    // Обработка полученных данных и выполнение соответствующих операций
    char* filename = NULL;
    char* query = NULL;
    char* key = NULL;
    char* basename = NULL;
    char* item = NULL;
    int temp;
    char* result = NULL;
    if (argc < 4 || argc > 7) {
        result = malloc(100);
        sprintf(result, "Error.\n");
        goto skip;
    }
    for (int i = 0; i < argc; i++) {
        if (strcmp(argv[i], "--file") == 0 && i + 1 < argc) {
            filename = argv[i + 1];
        }
        else if (strcmp(argv[i], "--query") == 0 && i + 1 < argc) {
            query = argv[i + 1];
            temp = i + 1;
            basename = argv[i + 2];
            if (i + 5 > argc) key = argv[i + 3];
            else {
                item = argv[i + 3];
                key = argv[i + 4];
                if (key == NULL || item == NULL) {
                    result = malloc(100);
                    sprintf(result, "Error.\n");
                    goto skip;
                }
            }
        }
    }
    int pos1 = 0;;
    int pos2 = 0;;
    int status = 0;;
    if (filename != NULL && query != NULL) {
        FILE* file = fopen(filename, "r");
        if (!file) {
            FILE* file = fopen(filename, "w");
        }
        if (strcmp(argv[temp], "SPUSH") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            Stack* stack = loadFromFileStack(filename, basename, &pos1, &pos2, &status);
            if (stack == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    SPUSH(stack, key);
                    result = malloc(strlen(key) + 5);
                    sprintf(result, "-> %s\n", key);
                    if (status == 1) status = 0;
                    fclose(file);
                    saveToFileStack(stack, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "SPOP") == 0) {
            Stack* stack = loadFromFileStack(filename, basename, &pos1, &pos2, &status);
            if (stack == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(40);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    char* element = SPOP(stack);
                    result = malloc(strlen(element) + 5);
                    sprintf(result, "-> %s\n", element);
                    if (status == 2) status = 0;
                    fclose(file);
                    saveToFileStack(stack, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "SADD") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            Set* set = loadFromFileSet(filename, basename, &pos1, &pos2, &status);
            if (set == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    SADD(set, key);
                    result = malloc(strlen(key) + 5);
                    sprintf(result, "-> %s\n", key);
                    if (status == 1) status = 0;
                    fclose(file);
                    saveToFileSet(set, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "SREM") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            Set* set = loadFromFileSet(filename, basename, &pos1, &pos2, &status);
            if (set == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    SREM(set, key);
                    result = malloc(strlen(key) + 5);
                    sprintf(result, "-> %s\n", key);
                    if (status == 2) status = 0;
                    fclose(file);
                    saveToFileSet(set, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "SISMEMBER") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            Set* set = loadFromFileSet(filename, basename, &pos1, &pos2, &status);
            if (set == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    result = malloc(100);
                    if (SISMEMBER(set, key)) sprintf(result, "-> True\n");
                    else sprintf(result, "-> False\n");
                    fclose(file);
                }
            }
        }
        if (strcmp(argv[temp], "QPUSH") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            Queue* queue = loadFromFileQueue(filename, basename, &pos1, &pos2, &status);
            if (queue == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    QPUSH(queue, key);
                    result = malloc(strlen(key) + 5);
                    sprintf(result, "-> %s\n", key);
                    if (status == 1) status = 0;
                    fclose(file);
                    saveToFileQueue(queue, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "QPOP") == 0) {
            Queue* queue = loadFromFileQueue(filename, basename, &pos1, &pos2, &status);
            if (queue == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    char* element = QPOP(queue);
                    result = malloc(strlen(element) + 5);
                    sprintf(result, "-> %s\n", element);
                    if (status == 2) status = 0;
                    fclose(file);
                    saveToFileQueue(queue, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "HSET") == 0) {
            if (key == NULL || item == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            HashTable* hashtable = loadFromFileTable(filename, basename, &pos1, &pos2, &status);
            if (hashtable == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    HSET(hashtable, key, item);
                    result = malloc(strlen(item) + strlen(key) + 20);
                    sprintf(result, "-> %s %s\n", item, key);
                    if (status == 1) status = 0;
                    fclose(file);
                    saveToFileTable(hashtable, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "HDEL") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            HashTable* hashtable = loadFromFileTable(filename, basename, &pos1, &pos2, &status);
            if (hashtable == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    HDEL(hashtable, key);
                    result = malloc(strlen(key) + 5);
                    sprintf(result, "-> %s\n", key);
                    if (status == 2) status = 0;
                    fclose(file);
                    saveToFileTable(hashtable, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "HGET") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            HashTable* hashtable = loadFromFileTable(filename, basename, &pos1, &pos2, &status);
            if (hashtable == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Error.\n");
                    fclose(file);
                }
                else {
                    if (HGET(hashtable, key) != NULL) {
                        result = malloc(strlen(HGET(hashtable, key)) + 15);
                        sprintf(result, "%s\n", HGET(hashtable, key));
                    }
                    else {
                        result = malloc(100);
                        sprintf(result, "-> False\n");
                    }
                    fclose(file);
                }
            }
        }
    }
    else {
        result = malloc(100);
        sprintf(result, "Error.\n");
    }
skip: {
    if (result == NULL) {
        result = malloc(100);
        sprintf(result, "Error.\n");
    }
    int bytes_sent = send(client_socket, result, strlen(result), 0); // Отправка результата клиенту
    closesocket(client_socket); // Закрытие сокета клиента
    free(argv);
    free(result);
    free(buffer);
    }
ReleaseMutex(mutex); // Освобождение мьютекса
}
========================================================================================================================================================================================
queue.c
========================================================================================================================================================================================
#define _CRT_SECURE_NO_WARNINGS  // Отключает предупреждения о небезопасных функциях CRT
#include "queue.h"  // Подключает заголовочный файл для работы с очередью
#include <stdio.h>  // Подключает стандартную библиотеку ввода-вывода
#include <stdlib.h>  // Подключает библиотеку, содержащую функции для работы с памятью, процессами и преобразованиями
#include <string.h>  // Подключает библиотеку для работы со строками

int countWordsInFileQueue(const char* filename) {  // Функция для подсчета слов в файле
    FILE* file = fopen(filename, "r");  // Открывает файл для чтения
    int count = 0;  // Переменная для подсчета слов
    char word[10000];  // Массив для хранения слов
    while (fscanf(file, "%s", word) != EOF) {  // Цикл для чтения слов из файла
        count++;  // Увеличивает счетчик слов
    }
    fclose(file);  // Закрывает файл
    return count;  // Возвращает количество слов в файле
}

Queue* initQueue() {  // Функция для инициализации очереди
    Queue* queue = (Queue*)malloc(sizeof(Queue));  // Выделяет память под структуру очереди
    queue->front = NULL;  // Устанавливает указатель на начало очереди в NULL
    queue->rear = NULL;  // Устанавливает указатель на конец очереди в NULL
    return queue;  // Возвращает указатель на очередь
}

void QPUSH(Queue* queue, char* element) {  // Функция для добавления элемента в очередь
    NodeQueue* newNode = (NodeQueue*)malloc(sizeof(NodeQueue));  // Выделяет память под новый узел очереди
    newNode->element = _strdup(element);  // Копирует элемент в новый узел
    newNode->next = NULL;  // Устанавливает указатель на следующий узел в NULL
    if (queue->front == NULL) {  // Если очередь пуста
        queue->front = newNode;  // Устанавливает новый узел как начало очереди
        queue->rear = newNode;  // Устанавливает новый узел как конец очереди
    }
    else {  // Если в очереди уже есть элементы
        queue->rear->next = newNode;  // Добавляет новый узел в конец очереди
        queue->rear = newNode;  // Устанавливает новый узел как конец очереди
    }
}

char* QPOP(Queue* queue) {  // Функция для удаления элемента из очереди
    if (queue->front == NULL) {  // Если очередь пуста
        return ("The queue is empty");  // Возвращает сообщение об ошибке
    }
    NodeQueue* poppedNode = queue->front;  // Сохраняет указатель на узел, который нужно удалить
    char* element = poppedNode->element;  // Сохраняет элемент, который нужно удалить
    queue->front = poppedNode->next;  // Перемещает указатель на начало очереди на следующий узел
    if (queue->front == NULL) {  // Если очередь стала пустой
        queue->rear = NULL;  // Устанавливает указатель на конец очереди в NULL
    }
    free(poppedNode);  // Освобождает память, занятую узлом
    return element;  // Возвращает удаленный элемент
}

void saveToFileQueue(Queue* queue, const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
    FILE* file = fopen(filename, "r");
    FILE* tempFile = fopen("temp.data", "w");
    int ch;
    fseek(file, 0, SEEK_SET);
    fseek(tempFile, 0, SEEK_SET);
    while ((ch = fgetc(file)) != EOF) {
        fputc(ch, tempFile);
        if (ftell(tempFile) == *pos1 - 2 && *status == 2)
            fprintf(tempFile, "\t%s", queue->front->element);
        else if (ftell(tempFile) == *pos1) {
            NodeQueue* currentNode = queue->front;
            while (currentNode != NULL) {
                if (currentNode->next == NULL)
                    fprintf(tempFile, "%s\n", currentNode->element);
                else
                    fprintf(tempFile, "%s\t", currentNode->element);
                currentNode = currentNode->next;
            }
            if (*status == 1) {
                fseek(tempFile, *pos1 - 1, SEEK_SET);
                fprintf(tempFile, "\n");
            }
            fseek(file, *pos2, SEEK_SET);
        }
    }
    free(queue->rear);
    free(queue->front);
    free(queue);
    fclose(file);
    fclose(tempFile);
    remove(filename);
    rename("temp.data", filename);
}

Queue* loadFromFileQueue(const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
    FILE* file = fopen(filename, "r");
    if (file == NULL) {
        return NULL;
    }
    int num_lines = countWordsInFileQueue(filename);
    char** line = malloc(num_lines * sizeof(char*));
    for (int i = 0; i < num_lines; i++) line[i] = malloc(10000 * sizeof(char));
    Queue* queue = initQueue();
    int tempory = 0;
    int pos3 = 0;
    int temp1 = 0;
    int temp2 = 0;
    char c = '1';
    for (int i = 0; i < num_lines; ++i) {
        fscanf(file, "%s", line[i]);
        c = getc(file);
        pos3 = ftell(file);
        if (!strcmp(line[i], basename)) {
            fseek(file, -3 - strlen(line[i]), SEEK_CUR);
            if (getc(file) == '\n' || i == 0) {
                fseek(file, pos3, SEEK_SET);
                tempory = 1;
                *pos1 = ftell(file);
                temp1 = i + 1;
            }
            else fseek(file, pos3, SEEK_SET);
        }
        if (c == '\n' && tempory == 1) {
            temp2 = i;
            *pos2 = ftell(file);
            tempory = 0;
        }
        if (feof(file))
            break;
    }
    if (temp1 == temp2)
        *status = 1;
    if (temp1 == temp2 + 1)
        *status = 2;
    while (temp1 < temp2 + 1) {
        QPUSH(queue, line[temp1]);
        temp1++;
    }
    fclose(file);
    for (int i = 0; i < num_lines; i++) {
        free(line[i]);
    }
    free(line);
    return queue;
}
========================================================================================================================================================================================
queue.h
========================================================================================================================================================================================
#ifndef QUEUE_H
#define QUEUE_H

typedef struct NodeQueue {
    char* element;
    struct NodeQueue* next;
} NodeQueue;

typedef struct Queue {
    NodeQueue* front;
    NodeQueue* rear;
} Queue;

Queue* initQueue();

void QPUSH(Queue* queue, char* element);

char* QPOP(Queue* queue);

void saveToFileQueue(Queue* queue, const char* filename, const char* basename, int *pos1, int *pos2, int *status);

Queue* loadFromFileQueue(const char* filename, const char* basename, int *pos1, int *pos2, int *status);

#endif
========================================================================================================================================================================================
set.c
========================================================================================================================================================================================
#define _CRT_SECURE_NO_WARNINGS  // Отключает предупреждения о небезопасных функциях CRT
#include "set.h"  // Подключает заголовочный файл для работы с множествами
#include <stdio.h>  // Подключает стандартную библиотеку ввода-вывода
#include <stdlib.h>  // Подключает библиотеку, содержащую функции для работы с памятью, процессами и преобразованиями
#include <string.h>  // Подключает библиотеку для работы со строками
#define MAX_SIZE 100000  // Определяет максимальный размер хеш-таблицы

int countWordsInFileSet(const char* filename) {  // Функция для подсчета слов в файле
    FILE* file = fopen(filename, "r");  // Открывает файл для чтения
    int count = 0;  // Переменная для подсчета слов
    char word[10000];  // Массив для хранения слов
    while (fscanf(file, "%s", word) != EOF) {  // Цикл для чтения слов из файла
        count++;  // Увеличивает счетчик слов
    }
    fclose(file);  // Закрывает файл
    return count;  // Возвращает количество слов в файле
}

Set* initSet() {  // Функция для инициализации множества
    Set* set = (Set*)malloc(sizeof(Set));  // Выделяет память под структуру множества
    set->head = NULL;  // Устанавливает указатель на голову множества в NULL
    set->size = 0;  // Устанавливает размер множества в 0
    set->tableSize = MAX_SIZE;  // Устанавливает размер хеш-таблицы
    set->hashTable = (Node**)malloc(MAX_SIZE * sizeof(Node*));  // Выделяет память под хеш-таблицу
    set->emptySlots = (int*)malloc(MAX_SIZE * sizeof(int));  // Выделяет память под массив пустых слотов
    for (int i = 0; i < MAX_SIZE; i++) {  // Цикл для инициализации хеш-таблицы и массива пустых слотов
        set->hashTable[i] = NULL;  // Устанавливает каждый элемент хеш-таблицы в NULL
        set->emptySlots[i] = 1;  // Устанавливает каждый элемент массива пустых слотов в 1
    }
    return set;  // Возвращает указатель на множество
}

int calculateHashS(const char* element) {  // Функция для вычисления хеша элемента
    int hash = 0;  // Переменная для хранения хеша
    for (int i = 0; element[i] != '\0'; i++) {  // Цикл для обработки каждого символа элемента
        hash = 31 * hash + element[i];  // Вычисляет хеш
    }
    return abs(hash) % MAX_SIZE;  // Возвращает абсолютное значение хеша, ограниченное максимальным размером
}

void SADD(Set* set, char* element) {  // Функция для добавления элемента в множество
    int hash = calculateHashS(element);  // Вычисляет хеш элемента
    if (set->hashTable[hash] != NULL) {  // Если в хеш-таблице уже есть элемент с таким хешем
        return;  // Возвращает управление
    }
    Node* newNode = (Node*)malloc(sizeof(Node));  // Выделяет память под новый узел
    newNode->element = _strdup(element);  // Копирует элемент в новый узел
    newNode->hash = hash;  // Сохраняет хеш в новом узле
    newNode->next = set->head;  // Устанавливает указатель на следующий узел в голову множества
    if (set->head != NULL) {  // Если множество не пусто
        set->head->prev = newNode;  // Устанавливает указатель на предыдущий узел головы множества в новый узел
    }
    set->head = newNode;  // Устанавливает новый узел как голову множества
    set->hashTable[hash] = newNode;  // Сохраняет новый узел в хеш-таблице
    set->size++;  // Увеличивает размер множества
}

void SREM(Set* set, const char* element) {  // Функция для удаления элемента из множества
    int hash = calculateHashS(element);  // Вычисляет хеш элемента
    if (set->hashTable[hash] != NULL && strcmp(set->hashTable[hash]->element, element) == 0) {  // Если в хеш-таблице есть элемент с таким хешем и элемент совпадает
        Node* nodeToRemove = set->hashTable[hash];  // Сохраняет указатель на узел, который нужно удалить
        if (nodeToRemove == set->head) {  // Если узел является головой множества
            set->head = nodeToRemove->next;  // Перемещает указатель на голову множества на следующий узел
        }
        else {  // Если узел не является головой множества
            if (nodeToRemove->prev != NULL) {  // Если у узла есть предыдущий узел
                nodeToRemove->prev->next = nodeToRemove->next;  // Перемещает указатель на следующий узел предыдущего узла на следующий узел удаляемого узла
            }
        }
        if (nodeToRemove->next != NULL) {  // Если у узла есть следующий узел
            nodeToRemove->next->prev = nodeToRemove->prev;  // Перемещает указатель на предыдущий узел следующего узла на предыдущий узел удаляемого узла
        }
        free(nodeToRemove->element);  // Освобождает память, занятую элементом удаляемого узла
        free(nodeToRemove);  // Освобождает память, занятую узлом
        set->hashTable[hash] = NULL;  // Устанавливает элемент хеш-таблицы с хешем удаляемого элемента в NULL
        set->size--;  // Уменьшает размер множества
        return;  // Возвращает управление
    }
}

int SISMEMBER(Set* set, const char* element) {  // Функция для проверки, содержит ли множество элемент
    int hash = calculateHashS(element);  // Вычисляет хеш элемента
    if (set->hashTable[hash] != NULL && strcmp(set->hashTable[hash]->element, element) == 0) {  // Если в хеш-таблице есть элемент с таким хешем и элемент совпадает
        return 1;  // Возвращает 1 (истина)
    }
    return 0;  // Возвращает 0 (ложь)
}

void saveToFileSet(Set* set, const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
    FILE* file = fopen(filename, "r");
    FILE* tempFile = fopen("temp.data", "w");
    int ch;
    fseek(file, 0, SEEK_SET);
    fseek(tempFile, 0, SEEK_SET);
    char** elements = (char**)malloc(set->size * sizeof(char*));
    Node* current = set->head;
    int i = 0;
    while (current != NULL) {
        elements[i] = current->element;
        current = current->next;
        i++;
    }
    while ((ch = fgetc(file)) != EOF) {
        fputc(ch, tempFile);
        if (ftell(tempFile) == *pos1 - 2 && *status == 2)
            fprintf(tempFile, "\t%s", set->head->element);
        else if (ftell(tempFile) == *pos1) {
            for (int j = set->size - 1; j >= 0; j--) {
                fprintf(tempFile, "%s", elements[j]);
                if (j > 0)
                    fprintf(tempFile, "\t");
                else
                    fprintf(tempFile, "\n");
            }
            if (*status == 1) {
                fseek(tempFile, *pos1 - 1, SEEK_SET);
                fprintf(tempFile, "\n");
            }
            fseek(file, *pos2, SEEK_SET);
        }
    }
    free(elements);
    free(set->hashTable);
    free(set->emptySlots);
    free(set);
    fclose(file);
    fclose(tempFile);
    remove("2.data");
    rename("temp.data", "2.data");
}

Set* loadFromFileSet(const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
    FILE* file = fopen(filename, "r");
    if (file == NULL) {
        return NULL;
    }
    int num_lines = countWordsInFileSet(filename);
    char** line = malloc(num_lines * sizeof(char*));
    for (int i = 0; i < num_lines; i++) line[i] = malloc(10000 * sizeof(char));
    Set* set = initSet();
    int tempory = 0;
    int pos3 = 0;
    int temp1 = 0;
    int temp2 = 0;
    char c = '1';
    for (int i = 0; i < num_lines; ++i) {
        fscanf(file, "%s", line[i]);
        c = getc(file);
        pos3 = ftell(file);
        if (!strcmp(line[i], basename)) {
            fseek(file, -3 - strlen(line[i]), SEEK_CUR);
            if (getc(file) == '\n' || i == 0) {
                fseek(file, pos3, SEEK_SET);
                tempory = 1;
                *pos1 = ftell(file);
                temp1 = i + 1;
            }
            else fseek(file, pos3, SEEK_SET);
        }
        if (c == '\n' && tempory == 1) {
            temp2 = i;
            *pos2 = ftell(file);
            tempory = 0;
        }
        if (feof(file))
            break;
    }
    if (temp1 == temp2)
        *status = 1;
    if (temp1 == temp2 + 1)
        *status = 2;
    while (temp1 < temp2 + 1) {
        SADD(set, line[temp1]);
        temp1++;
    }
    fclose(file);
    for (int i = 0; i < num_lines; i++) {
        free(line[i]);
    }
    free(line);
    return set;
}
========================================================================================================================================================================================
set.h
========================================================================================================================================================================================
#ifndef SET_H
#define SET_H

typedef struct Node {
    char* element;
    int hash;
    struct Node* next;
    struct Node* prev;
} Node;

typedef struct Set {
    Node* head;
    int size;
    Node** hashTable;
    int tableSize;
    int* emptySlots;
} Set;

Set* initSet();

void SADD(Set* set, char* element);

void SREM(Set* set, char* element);

int SISMEMBER(Set* set, char* element);

void saveToFileSet(Set* set, const char* filename, const char* basename, int *pos1, int *pos2, int *status);

Set* loadFromFileSet(const char* filename, const char* basename, int *pos1, int *pos2, int *status);

#endif
========================================================================================================================================================================================
stack.c
========================================================================================================================================================================================
#define _CRT_SECURE_NO_WARNINGS  // Отключает предупреждения о небезопасных функциях CRT
#include "stack.h"  // Подключает заголовочный файл для работы со стеком
#include <stdio.h>  // Подключает стандартную библиотеку ввода-вывода
#include <stdlib.h>  // Подключает библиотеку, содержащую функции для работы с памятью, процессами и преобразованиями
#include <string.h>  // Подключает библиотеку для работы со строками

int countWordsInFileStack(const char* filename) {  // Функция для подсчета слов в файле
    FILE* file = fopen(filename, "r");  // Открывает файл для чтения
    int count = 0;  // Переменная для подсчета слов
    char word[10000];  // Массив для хранения слов
    while (fscanf(file, "%s", word) != EOF) {  // Цикл для чтения слов из файла
        count++;  // Увеличивает счетчик слов
    }
    fclose(file);  // Закрывает файл
    return count;  // Возвращает количество слов в файле
}

Stack* initStack() {  // Функция для инициализации стека
    Stack* stack = (Stack*)malloc(sizeof(Stack));  // Выделяет память под структуру стека
    stack->top = NULL;  // Устанавливает указатель на вершину стека в NULL
    return stack;  // Возвращает указатель на стек
}

void SPUSH(Stack* stack, char* element) {  // Функция для добавления элемента в стек
    NodeStack* newNode = (NodeStack*)malloc(sizeof(NodeStack));  // Выделяет память под новый узел стека
    newNode->element = _strdup(element);  // Копирует элемент в новый узел
    newNode->next = stack->top;  // Устанавливает указатель на следующий узел в вершину стека
    stack->top = newNode;  // Устанавливает новый узел как вершину стека
}

char* SPOP(Stack* stack) {  // Функция для удаления элемента из стека
    if (stack->top == NULL) {  // Если стек пуст
        return ("The stack is empty");  // Возвращает сообщение об ошибке
    }
    NodeStack* poppedNode = stack->top;  // Сохраняет указатель на узел, который нужно удалить
    stack->top = poppedNode->next;  // Перемещает указатель на вершину стека на следующий узел
    char* element = poppedNode->element;  // Сохраняет элемент, который нужно удалить
    free(poppedNode);  // Освобождает память, занятую узлом
    return element;  // Возвращает удаленный элемент
}

void saveToFileStack(Stack* stack, const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
    FILE* file = fopen(filename, "r");
    FILE* tempFile = fopen("temp.data", "w");
    int ch;
    fseek(file, 0, SEEK_SET);
    fseek(tempFile, 0, SEEK_SET);
    while ((ch = fgetc(file)) != EOF) {
        fputc(ch, tempFile);
        if (ftell(tempFile) == *pos1 - 2 && *status == 2)
            fprintf(tempFile, "\t%s", stack->top->element);
        else if (ftell(tempFile) == *pos1) {
            NodeStack* currentNode = stack->top;
            NodeStack* prevNode = NULL;
            while (currentNode != NULL) {
                NodeStack* nextNode = currentNode->next;
                currentNode->next = prevNode;
                prevNode = currentNode;
                currentNode = nextNode;
            }
            currentNode = prevNode;
            while (currentNode != NULL) {
                if (currentNode->next == NULL)
                    fprintf(tempFile, "%s\n", currentNode->element);
                else
                    fprintf(tempFile, "%s\t", currentNode->element);
                currentNode = currentNode->next;
            }
            if (*status == 1) {
                fseek(tempFile, *pos1 - 1, SEEK_SET);
                fprintf(tempFile, "\n");
            }
            fseek(file, *pos2, SEEK_SET);
        }
    }
    free(stack->top);
    free(stack);
    fclose(file);
    fclose(tempFile);
    remove(filename);
    rename("temp.data", filename);
}

Stack* loadFromFileStack(const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
    FILE* file = fopen(filename, "r");
    if (file == NULL) {
        return NULL;
    }
    int num_lines = countWordsInFileStack(filename);
    char** line = malloc(num_lines * sizeof(char*));
    for (int i = 0; i < num_lines; i++) line[i] = malloc(10000 * sizeof(char));
    Stack* stack = initStack();
    int tempory = 0;
    int pos3 = 0;
    int temp1 = 0;
    int temp2 = 0;
    char c = '1';
    for (int i = 0; i < num_lines; ++i) {
        fscanf(file, "%s", line[i]);
        c = getc(file);
        pos3 = ftell(file);
        if (!strcmp(line[i], basename)) {
            fseek(file,  -3 - strlen(line[i]), SEEK_CUR);
            if (getc(file) == '\n' || i == 0) {
                fseek(file, pos3, SEEK_SET);
                tempory = 1;
                *pos1 = ftell(file);
                temp1 = i + 1;
            }
            else fseek(file, pos3, SEEK_SET);
        }
        if (c == '\n' && tempory == 1) {
            temp2 = i;
            *pos2 = ftell(file);
            tempory = 0;
        }
        if (feof(file))
            break;
    }
    if (temp1 == temp2)
        *status = 1;
    if (temp1 == temp2 + 1)
        *status = 2;
    while (temp1 < temp2 + 1) {
        SPUSH(stack, line[temp1]);
        temp1++;
    }
    fclose(file);
    for (int i = 0; i < num_lines; i++) {
        free(line[i]);
    }
    free(line);
    return stack;
}
========================================================================================================================================================================================
stack.h
========================================================================================================================================================================================
#ifndef STACK_H
#define STACK_H

typedef struct NodeStack {
    char* element;
    struct NodeStack* next;
} NodeStack;

typedef struct Stack {
    NodeStack* top;
} Stack;

Stack* initStack();

void SPUSH(Stack* stack, char* element);

char* SPOP(Stack* stack);

void saveToFileStack(Stack* stack, const char* filename, const char* basename, int *pos1, int *pos2, int *status);

Stack* loadFromFileStack(const char* filename, const char* basename, int *pos1, int *pos2, int *status);

#endif
========================================================================================================================================================================================
table.c
========================================================================================================================================================================================
#define _CRT_SECURE_NO_WARNINGS  // Отключает предупреждения о небезопасных функциях CRT
#include "table.h"  // Подключает заголовочный файл для работы с хеш-таблицей
#include <stdio.h>  // Подключает стандартную библиотеку ввода-вывода
#include <stdlib.h>  // Подключает библиотеку, содержащую функции для работы с памятью, процессами и преобразованиями
#include <string.h>  // Подключает библиотеку для работы со строками
#define MAX_SIZE 100000  // Определяет максимальный размер хеш-таблицы

int countWordsInFileTable(const char* filename) {  // Функция для подсчета слов в файле
    FILE* file = fopen(filename, "r");  // Открывает файл для чтения
    int count = 0;  // Переменная для подсчета слов
    char word[10000];  // Массив для хранения слов
    while (fscanf(file, "%s", word) != EOF) {  // Цикл для чтения слов из файла
        count++;  // Увеличивает счетчик слов
    }
    fclose(file);  // Закрывает файл
    return count;  // Возвращает количество слов в файле
}

HashTable* initHashTable() {  // Функция для инициализации хеш-таблицы
    HashTable* ht = (HashTable*)malloc(sizeof(HashTable));  // Выделяет память под структуру хеш-таблицы
    ht->head = NULL;  // Устанавливает указатель на голову хеш-таблицы в NULL
    ht->size = 0;  // Устанавливает размер хеш-таблицы в 0
    ht->tableSize = MAX_SIZE;  // Устанавливает размер таблицы в MAX_SIZE
    ht->hashTable = (NodeHashTable**)malloc(MAX_SIZE * sizeof(NodeHashTable*));  // Выделяет память под хеш-таблицу
    ht->keys = (char**)malloc(MAX_SIZE * sizeof(char*));  // Выделяет память под массив ключей
    for (int i = 0; i < MAX_SIZE; i++) {  // Цикл для инициализации хеш-таблицы и массива ключей
        ht->hashTable[i] = NULL;  // Устанавливает каждый элемент хеш-таблицы в NULL
        ht->keys[i] = NULL;  // Устанавливает каждый элемент массива ключей в NULL
    }
    return ht;  // Возвращает указатель на хеш-таблицу
}

int calculateHashT(const char* element) {  // Функция для вычисления хеша элемента
    int hash = 0;  // Переменная для хранения хеша
    for (int i = 0; element[i] != '\0'; i++) {  // Цикл для обработки каждого символа элемента
        hash = 31 * hash + element[i];  // Вычисляет хеш
    }
    return abs(hash) % MAX_SIZE;  // Возвращает абсолютное значение хеша, ограниченное максимальным размером
}

void HSET(HashTable* ht, char* key, char* value) {  // Функция для добавления пары ключ-значение в хеш-таблицу
    int hash = calculateHashT(key);  // Вычисляет хеш ключа
    if (ht->hashTable[hash] != NULL) {  // Если в хеш-таблице уже есть элемент с таким хешем
        return;  // Возвращает управление
    }
    NodeHashTable* newNode = (NodeHashTable*)malloc(sizeof(NodeHashTable));  // Выделяет память под новый узел хеш-таблицы
    newNode->element = _strdup(value);  // Копирует значение в новый узел
    newNode->hash = hash;  // Сохраняет хеш в новом узле
    newNode->next = ht->head;  // Устанавливает указатель на следующий узел в голову хеш-таблицы
    if (ht->head != NULL) {  // Если хеш-таблица не пуста
        ht->head->prev = newNode;  // Устанавливает указатель на предыдущий узел головы хеш-таблицы в новый узел
    }
    ht->head = newNode;  // Устанавливает новый узел как голову хеш-таблицы
    ht->hashTable[hash] = newNode;  // Сохраняет новый узел в хеш-таблице
    ht->size++;  // Увеличивает размер хеш-таблицы
    ht->keys[ht->size - 1] = _strdup(key);  // Сохраняет ключ в массиве ключей
}

char* HGET(HashTable* ht, const char* key) {  // Функция для получения значения по ключу из хеш-таблицы
    if (ht->hashTable[calculateHashT(key)] != NULL) {  // Если в хеш-таблице есть элемент с таким хешем
        return ht->hashTable[calculateHashT(key)]->element;  // Возвращает значение этого элемента
    }
    return NULL;  // Возвращает NULL, если элемента с таким хешем нет
}

void HDEL(HashTable* ht, const char* key) {  // Функция для удаления элемента из хеш-таблицы
    if (ht->hashTable[calculateHashT(key)] != NULL) {  // Если в хеш-таблице есть элемент с таким хешем
        NodeHashTable* nodeToRemove = ht->hashTable[calculateHashT(key)];  // Сохраняет указатель на узел, который нужно удалить
        if (nodeToRemove == ht->head) {  // Если узел является головой хеш-таблицы
            ht->head = nodeToRemove->next;  // Перемещает указатель на голову хеш-таблицы на следующий узел
        }
        else {  // Если узел не является головой хеш-таблицы
            if (nodeToRemove->prev != NULL) {  // Если у узла есть предыдущий узел
                nodeToRemove->prev->next = nodeToRemove->next;  // Перемещает указатель на следующий узел предыдущего узла на следующий узел удаляемого узла
            }
        }
        if (nodeToRemove->next != NULL) {  // Если у узла есть следующий узел
            nodeToRemove->next->prev = nodeToRemove->prev;  // Перемещает указатель на предыдущий узел следующего узла на предыдущий узел удаляемого узла
        }
        free(nodeToRemove->element);  // Освобождает память, занятую элементом удаляемого узла
        free(nodeToRemove);  // Освобождает память, занятую узлом
        ht->hashTable[calculateHashT(key)] = NULL;  // Устанавливает элемент хеш-таблицы с хешем удаляемого элемента в NULL
        ht->size--;  // Уменьшает размер хеш-таблицы
        return;  // Возвращает управление
    }
}

void saveToFileTable(HashTable* hashtable, const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
	FILE* file = fopen(filename, "r");
	FILE* tempFile = fopen("temp.data", "w");
	int ch;
	fseek(file, 0, SEEK_SET);
	fseek(tempFile, 0, SEEK_SET);
	while ((ch = fgetc(file)) != EOF) {
		fputc(ch, tempFile);
		if (ftell(tempFile) == *pos1 - 2 && *status == 2) {
			fprintf(tempFile, "\t%s\t%s", hashtable->hashTable[calculateHashT(hashtable->keys[0])]->element, hashtable->keys[0]);
		}
		else if (ftell(tempFile) == *pos1) {
			for (int i = 0; i < hashtable->size; i++) {
				if (i == hashtable->size - 1) {
					fprintf(tempFile, "%s\t%s\n", hashtable->hashTable[calculateHashT(hashtable->keys[i])]->element, hashtable->keys[i]);
				}
				else {
					fprintf(tempFile, "%s\t%s\t", hashtable->hashTable[calculateHashT(hashtable->keys[i])]->element, hashtable->keys[i]);
				}
			}
			if (*status == 1) {
				fseek(tempFile, *pos1 - 1, SEEK_SET);
				fprintf(tempFile, "\n");
			}
			fseek(file, *pos2, SEEK_SET);
		}
	}
	free(hashtable->hashTable);
	free(hashtable->keys);
	free(hashtable);
	fclose(file);
	fclose(tempFile);
	remove(filename);
	rename("temp.data", filename);
}

HashTable* loadFromFileTable(const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
	FILE* file = fopen(filename, "r");
	int num_lines = countWordsInFileTable(filename);
	char** line = malloc(num_lines * sizeof(char*));
	for (int i = 0; i < num_lines; i++) line[i] = malloc(10000 * sizeof(char));
	HashTable* hashtable = initHashTable();
	int tempory = 0;
	int tempory2 = 0;
	int count = 0;
	int temp1 = 0;
	int temp2 = 0;
	char c = '1';
	for (int i = 0; i < num_lines; ++i) {
		fscanf(file, "%s", line[i]);
		c = getc(file);
		if (c == '\n') {
			tempory2 = ftell(file);
		}
		if (!strcmp(line[i], basename) && (tempory2 == ftell(file) || tempory2 == ftell(file) - strlen(line[i]) - 1 || i == 0)) {
			tempory = 1;
			*pos1 = ftell(file);
			*pos2 = strlen(line[i]);
			temp1 = i + 1;
		}
		if (c == '\n' && tempory == 1) {
			temp2 = i;
			*pos2 = ftell(file);
			tempory = 0;
			count++;
		}
		if (feof(file))
			break;
	}
	if (temp1 + 1 == temp2) *status = 1;
	if (temp1 == temp2 + 1) *status = 2;
	while (temp1 < temp2) {
		char* value = line[temp1];
		char* key = line[temp1 + 1];
		HSET(hashtable, key, value);
		temp1 += 2;
	}
	fclose(file);
	for (int i = 0; i < num_lines; i++) {
		free(line[i]);
	}
	free(line);
	return hashtable;
}
========================================================================================================================================================================================
table.h
========================================================================================================================================================================================
#ifndef TABLE_H
#define TABLE_H

typedef struct NodeHashTable {
    char* element;
    int hash;
    struct NodeHashTable* next;
    struct NodeHashTable* prev;
} NodeHashTable;

typedef struct HashTable {
    NodeHashTable* head;
    int size;
    NodeHashTable** hashTable;
    int tableSize;
    char** keys;
} HashTable;

HashTable* initHashTable();

void HSET(HashTable* hashtable, char* key, char* value);

void HDEL(HashTable* hashtable, char* key);

char* HGET(HashTable* hashtable, char* key);

void saveToFileTable(HashTable* hashtable, const char* filename, const char* basename, int *pos1, int *pos2, int *status);

HashTable* loadFromFileTable(const char* filename, const char* basename, int *pos1, int *pos2, int *status);

#endif
========================================================================================================================================================================================
Python
========================================================================================================================================================================================
# Импортируем необходимые библиотеки
import string
import random
import socket
from flask import Flask, request, redirect
from flask_cors import CORS
import time
import requests
import datetime

# Создаем экземпляр приложения Flask
app = Flask(__name__)
# Разрешаем кросс-доменные запросы
CORS(app)

# Определяем маршрут для формы
@app.route('/form', methods=['GET'])
def form():
    # Возвращаем HTML-форму для ввода URL
    return '''
    <!DOCTYPE html>
<html>
<body>

<h2>Сокращения URL</h2>

<form id="myForm">
  <label for="url">Введите URL:</label><br>
  <input type="text" id="url" name="url"><br>
  <input type="submit" value="Сократить URL">
</form> 

<p id="shortUrl"></p>

<script>
document.getElementById('myForm').addEventListener('submit', function(e) {
  e.preventDefault();
  var url = document.getElementById('url').value;
  if(url.trim() === '') {
    document.getElementById('shortUrl').innerText = 'Пожалуйста, введите URL';
    return;
  }
  if(new Blob([url]).size > 50000) {
    document.getElementById('shortUrl').innerText = 'URL не должен превышать 50000 байт';
    return;
  }
  fetch('/', {
    method: 'POST',
    headers: {
      'Content-Type': 'text/plain'
    },
    body: url
  }).then(function(response) {
    if (!response.ok) {
      throw new Error('Ошибка сети при попытке сократить URL');
    }
    return response.text();
  }).then(function(text) {
    if (text === 'Error.') {
      document.getElementById('shortUrl').innerText = 'Произошла ошибка при обработке вашего запроса';
    } else {
      document.getElementById('shortUrl').innerText = 'Ваш сокращенный URL: ' + text;
    }
  }).catch(function(error) {
    document.getElementById('shortUrl').innerText = 'Произошла ошибка: ' + error.message;
  });
});
</script>

</body>
</html>
    '''

# Функция для генерации короткого URL
def generate_short_url():
    return ''.join(random.choices(string.ascii_letters + string.digits, k=8))

# Определяем маршрут для сокращения URL
@app.route('/', methods=['POST'])
def shorten_url():
    # Получаем URL из запроса
    url = request.data.decode()
    # Проверка на повтор и возврат имеющего значения
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.connect((SERVER_IP, SERVER_PORT))
            except Exception as e:
                return f'Не удалось подключиться к серверу: {str(e)}', 500
            s.sendall(f'--file urls.data --query HGET short_urls {url}'.encode())
            existing_url = s.recv(1024).decode()
            existing_url = existing_url.replace('\n', '').replace('\r', '')
            if existing_url == "Error.":
                return 'Error.', 500
            if existing_url != "-> False":
                return f'{request.url_root}SU/{existing_url}'
    while True:
        # Генерируем короткий URL
        short_url = generate_short_url()
        # Создаем сокет для связи с сервером
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                # Подключаемся к серверу
                s.connect((SERVER_IP, SERVER_PORT))
            except Exception as e:
                # Если возникла ошибка, возвращаем ее
                return f'Не удалось подключиться к серверу: {str(e)}', 500
            # Отправляем запрос на сервер
            s.sendall(f'--file urls.data --query HGET urls {short_url}'.encode())
            # Получаем ответ от сервера
            existing_url = s.recv(1024).decode()
            existing_url = existing_url.replace('\n', '').replace('\r', '')
            # Если возникла ошибка, возвращаем ее
            if existing_url == "Error.":
                return 'Error.', 500
            # Если URL не существует, создаем новый
            if existing_url == "-> False":
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    try:
                        # Подключаемся к серверу
                        s.connect((SERVER_IP, SERVER_PORT))
                    except Exception as e:
                        # Если возникла ошибка, возвращаем ее
                        return f'Не удалось подключиться к серверу: {str(e)}', 500
                    # Отправляем запрос на сервер
                    s.sendall(f'--file urls.data --query HSET urls {url} {short_url}'.encode())
                    # Если возникла ошибка, возвращаем ее
                    if s.recv(1024).decode().replace('\n', '').replace('\r', '') == "Error.":
                        return 'Error.', 500
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    try:
                        s.connect((SERVER_IP, SERVER_PORT))
                    except Exception as e:
                        return f'Не удалось подключиться к серверу: {str(e)}', 500
                    s.sendall(f'--file urls.data --query HSET short_urls {short_url} {url}'.encode())
                    if s.recv(1024).decode().replace('\n', '').replace('\r', '') == "Error.":
                        return 'Error.', 500
                # Возвращаем сокращенный URL
                return f'{request.url_root}SU/{short_url}', 201

# Определяем маршрут для перенаправления по короткому URL
@app.route('/SU/<short_url>', methods=['GET'])
def redirect_url(short_url):
    # Создаем сокет для связи с сервером
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            # Подключаемся к серверу
            s.connect((SERVER_IP, SERVER_PORT))
        except Exception as e:
            # Если возникла ошибка, возвращаем ее
            return f'Не удалось подключиться к серверу: {str(e)}', 500
        # Отправляем запрос на сервер
        s.sendall(f'--file urls.data --query HGET urls {short_url}'.encode())
        # Получаем ответ от сервера
        url = s.recv(1024).decode()
        url = url.replace('\n', '').replace('\r', '')
        # Если возникла ошибка, возвращаем ее
        if url == "Error.":
            return 'Error.', 500
    # Перенаправляем на исходный URL
    return redirect(url, code=302)

# Запускаем приложение
if __name__ == '__main__':
    # Получаем IP-адрес и порт сервера
    SERVER_IP, SERVER_PORT = input("Введите IP-адрес и порт сервера (формат: myip:myport): ").split(':')
    SERVER_PORT = int(SERVER_PORT)
    # Запускаем приложение в режиме отладки
    app.run(debug=True)
========================================================================================================================================================================================
Servis2.py
========================================================================================================================================================================================
import string
from flask import Flask, request, jsonify
from collections import defaultdict
import datetime
import socket
import requests
import json

# Создание экземпляра приложения Flask
app = Flask(__name__)

# Ввод IP-адреса и порта сервера СУБД
SERVER_IP, SERVER_PORT = input("Введите IP-адрес и порт сервера СУБД (формат: myip:myport): ").split(':')
SERVER_PORT = int(SERVER_PORT)

# Инициализация словарей для хранения статистики
statistics1 = defaultdict(list)
statistics2 = defaultdict(list)
statistics3 = defaultdict(list)
statistics4 = defaultdict(list)
statistics5 = defaultdict(list)
statistics6 = defaultdict(list)

# Функция для загрузки данных
def load():
    # Очистка словарей статистики
    statistics1.clear()
    statistics2.clear()
    statistics3.clear()
    statistics4.clear()
    statistics5.clear()
    statistics6.clear()

    global count_tik
    count_tik = 0
    last_ip = ""
    last_url = ""

    # Цикл для получения данных с сервера
    while True:
        count_tik = count_tik + 1
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                # Подключение к серверу
                s.connect((SERVER_IP, SERVER_PORT))
            except Exception as e:
                print (f'Не удалось подключиться к серверу: {str(e)}')

            # Отправка запроса на сервер
            s.sendall(f'--file urls.data --query HGET ip {count_tik}'.encode())

            # Получение ответа от сервера
            ip = s.recv(1024).decode()
            ip = ip.replace('\n', '').replace('\r', '')
            if ip == "Error.":
                print ('Error.')
            if ip == "-> False":
                ip = last_ip
            last_ip = ip

        # Аналогичные действия выполняются для url и timestamp
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.connect((SERVER_IP, SERVER_PORT))
            except Exception as e:
                print (f'Не удалось подключиться к серверу: {str(e)}')
            s.sendall(f'--file urls.data --query HGET url {count_tik}'.encode())
            url = s.recv(1024).decode()
            url = url.replace('\n', '').replace('\r', '')
            if url == "Error.":
                print ('Error.')
            if url == "-> False":
                url = last_url
            last_url = url

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.connect((SERVER_IP, SERVER_PORT))
            except Exception as e:
                print (f'Не удалось подключиться к серверу: {str(e)}')
            s.sendall(f'--file urls.data --query HGET timestamp {count_tik}'.encode())
            timestamp = s.recv(1024).decode()
            timestamp = timestamp.replace('\n', '').replace('\r', '')
            if timestamp == "Error.":
                print ('Error.')
            if timestamp == "-> False":
                break

        # Добавление полученных данных в словари статистики
        statistics1[url].append((ip, timestamp))
        statistics2[url].append((timestamp, ip))
        statistics3[ip].append((url, timestamp))
        statistics4[ip].append((timestamp, url))
        statistics5[timestamp].append((ip, url))
        statistics6[timestamp].append((url, ip))

# Обработчик POST-запросов на главную страницу
@app.route('/', methods=['POST'])
def post_statistics():
    # Загрузка данных
    load()

    # Получение данных из запроса
    ip = request.json['ip']
    url = request.json['url']
    timestamp = request.json['timestamp']

    # Отправка данных на сервер
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            s.connect((SERVER_IP, SERVER_PORT))
        except Exception as e:
            return f'Не удалось подключиться к серверу: {str(e)}', 500
        s.sendall(f'--file urls.data --query HSET ip {ip} {count_tik}'.encode())
        if s.recv(1024).decode().replace('\n', '').replace('\r', '') == "Error.":
            return 'Error.', 500
        s.close()

    # Аналогичные действия выполняются для url и timestamp
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            s.connect((SERVER_IP, SERVER_PORT))
        except Exception as e:
            return f'Не удалось подключиться к серверу: {str(e)}', 500
        s.sendall(f'--file urls.data --query HSET url {url} {count_tik}'.encode())
        if s.recv(1024).decode().replace('\n', '').replace('\r', '') == "Error.":
            return 'Error.', 500
        s.close()

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            s.connect((SERVER_IP, SERVER_PORT))
        except Exception as e:
            return f'Не удалось подключиться к серверу: {str(e)}', 500
        s.sendall(f'--file urls.data --query HSET timestamp {timestamp} {count_tik}'.encode())
        if s.recv(1024).decode().replace('\n', '').replace('\r', '') == "Error.":
            return 'Error.', 500
        s.close()

    # Добавление полученных данных в словари статистики
    statistics1[url].append((ip, timestamp))
    statistics2[url].append((timestamp, ip))
    statistics3[ip].append((url, timestamp))
    statistics4[ip].append((timestamp, url))
    statistics5[timestamp].append((ip, url))
    statistics6[timestamp].append((url, ip))

    # Возвращение ответа
    return '', 204

# Обработчик POST-запросов на страницу /report
@app.route('/report', methods=['POST'])
def report():
    # Загрузка данных
    load()

    # Получение данных из запроса
    dimensions = request.json['Dimensions']

    # Создание отчета
    report = []
    id = 1

    # Здесь выполняется анализ данных в зависимости от указанных измерений
    # и формирование отчета в виде списка словарей
    if (dimensions[0]=='URL' and dimensions[1]=='SourceIP'):
        for url, stats in statistics1.items():
            url_dict = {}
            for stat in stats:
                ip, timestamp = stat
                if ip not in url_dict:
                    url_dict[ip] = {'count': 1, 'timestamps': {timestamp: 1}}
                else:
                    if timestamp not in url_dict[ip]['timestamps']:
                        url_dict[ip]['timestamps'][timestamp] = 1
                    else:
                        url_dict[ip]['timestamps'][timestamp] += 1
            total_count = sum(sum(data['timestamps'].values()) for data in url_dict.values())
            report.append({
                'Id': id,
                'Pid': None,
                'URL': url,
                'SourceIP': None,
                'TimeInterval': None,
                'Count': total_count
            })
            id += 1
            for ip, data in url_dict.items():
                if 'SourceIP' in dimensions:
                    report.append({
                        'Id': id,
                        'Pid': 1,
                        'URL': None,
                        'SourceIP': ip,
                        'TimeInterval': None,
                        'Count': sum(data['timestamps'].values())
                    })
                    id += 1
                for timestamp, timestamp_count in data['timestamps'].items():
                    if 'TimeInterval' in dimensions:
                        report.append({
                            'Id': id,
                            'Pid': 2,
                            'URL': None,
                            'SourceIP': None,
                            'TimeInterval': str(timestamp),
                            'Count': timestamp_count
                        })
                        id += 1
    if (dimensions[0]=='URL' and dimensions[1]=='TimeInterval'):
        for url, stats in statistics2.items():
            url_dict = {}
            for stat in stats:
                timestamp, ip = stat
                if timestamp not in url_dict:
                    url_dict[timestamp] = {'count': 1, 'ips': {ip: 1}}
                else:
                    if ip not in url_dict[timestamp]['ips']:
                        url_dict[timestamp]['ips'][ip] = 1
                    else:
                        url_dict[timestamp]['ips'][ip] += 1
            total_count = sum(sum(data['ips'].values()) for data in url_dict.values())
            report.append({
                'Id': id,
                'Pid': None,
                'URL': url,
                'SourceIP': None,
                'TimeInterval': None,
                'Count': total_count
            })
            id += 1
            for timestamp, data in url_dict.items():
                if 'TimeInterval' in dimensions:
                    report.append({
                        'Id': id,
                        'Pid': 1,
                        'URL': None,
                        'SourceIP': None,
                        'TimeInterval': str(timestamp),
                        'Count': sum(data['ips'].values())
                    })
                    id += 1
                for ip, ip_count in data['ips'].items():
                    if 'SourceIP' in dimensions:
                        report.append({
                            'Id': id,
                            'Pid': 2,
                            'URL': None,
                            'SourceIP': ip,
                            'TimeInterval': None,
                            'Count': ip_count
                        })
                        id += 1
    if (dimensions[0]=='SourceIP' and dimensions[1]=='URL'):
        for ip, stats in statistics3.items():
            ip_dict = {}
            for stat in stats:
                url, timestamp = stat
                if url not in ip_dict:
                    ip_dict[url] = {'count': 1, 'timestamps': {timestamp: 1}}
                else:
                    if timestamp not in ip_dict[url]['timestamps']:
                        ip_dict[url]['timestamps'][timestamp] = 1
                    else:
                        ip_dict[url]['timestamps'][timestamp] += 1
            total_count = sum(sum(data['timestamps'].values()) for data in ip_dict.values())
            report.append({
                'Id': id,
                'Pid': None,
                'URL': None,
                'SourceIP': ip,
                'TimeInterval': None,
                'Count': total_count
            })
            id += 1
            for url, data in ip_dict.items():
                if 'URL' in dimensions:
                    report.append({
                        'Id': id,
                        'Pid': 1,
                        'URL': url,
                        'SourceIP': None,
                        'TimeInterval': None,
                        'Count': sum(data['timestamps'].values())
                    })
                    id += 1
                for timestamp, timestamp_count in data['timestamps'].items():
                    if 'TimeInterval' in dimensions:
                        report.append({
                            'Id': id,
                            'Pid': 2,
                            'URL': None,
                            'SourceIP': None,
                            'TimeInterval': str(timestamp),
                            'Count': timestamp_count
                        })
                        id += 1
    if (dimensions[0]=='SourceIP' and dimensions[1]=='TimeInterval'):
        for ip, stats in statistics4.items():
            report.append({
                'Id': id,
                'Pid': None,
                'URL': None,
                'SourceIP': ip,
                'TimeInterval': None,
                'Count': len(stats)
            })
            id += 1
            timestamp_dict = {}
            for stat in stats:
                timestamp, url = stat
                if timestamp not in timestamp_dict:
                    timestamp_dict[timestamp] = {'count': 1, 'urls': {url: 1}}
                else:
                    timestamp_dict[timestamp]['count'] += 1
                    if url not in timestamp_dict[timestamp]['urls']:
                        timestamp_dict[timestamp]['urls'][url] = 1
                    else:
                        timestamp_dict[timestamp]['urls'][url] += 1
            for timestamp, data in timestamp_dict.items():
                if 'TimeInterval' in dimensions:
                    report.append({
                        'Id': id,
                        'Pid': 1,
                        'URL': None,
                        'SourceIP': None,
                        'TimeInterval': str(timestamp),
                        'Count': data['count']
                    })
                    id += 1
                for url, url_count in data['urls'].items():
                    if 'URL' in dimensions:
                        report.append({
                            'Id': id,
                            'Pid': 2,
                            'URL': url,
                            'SourceIP': None,
                            'TimeInterval': None,
                            'Count': url_count
                        })
                        id += 1
    if (dimensions[0]=='TimeInterval' and dimensions[1]=='SourceIP'):
        for timestamp, stats in statistics5.items():
            report.append({
                'Id': id,
                'Pid': None,
                'URL': None,
                'SourceIP': None,
                'TimeInterval': str(timestamp),
                'Count': len(stats)
            })
            id += 1
            ip_dict = {}
            for stat in stats:
                ip, url = stat
                if ip not in ip_dict:
                    ip_dict[ip] = {'count': 1, 'urls': {url: 1}}
                else:
                    if url not in ip_dict[ip]['urls']:
                        ip_dict[ip]['count'] += 1
                        ip_dict[ip]['urls'][url] = 1
                    else:
                        ip_dict[ip]['urls'][url] += 1
            for ip, data in ip_dict.items():
                if 'SourceIP' in dimensions:
                    report.append({
                        'Id': id,
                        'Pid': 1,
                        'URL': None,
                        'SourceIP': ip,
                        'TimeInterval': None,
                        'Count': sum(data['urls'].values())
                    })
                    id += 1
                for url, url_count in data['urls'].items():
                    if 'URL' in dimensions:
                        report.append({
                            'Id': id,
                            'Pid': 2,
                            'URL': url,
                            'SourceIP': None,
                            'TimeInterval': None,
                            'Count': url_count
                        })
                        id += 1
    if (dimensions[0]=='TimeInterval' and dimensions[1]=='URL'):
        for timestamp, stats in statistics6.items():
            report.append({
                'Id': id,
                'Pid': None,
                'URL': None,
                'SourceIP': None,
                'TimeInterval': str(timestamp),
                'Count': len(stats)
            })
            id += 1
            url_dict = {}
            for stat in stats:
                url, ip = stat
                if url not in url_dict:
                    url_dict[url] = {'count': 1, 'ips': {ip: 1}}
                else:
                    if ip not in url_dict[url]['ips']:
                        url_dict[url]['ips'][ip] = 1
                    else:
                        url_dict[url]['ips'][ip] += 1
                    url_dict[url]['count'] = sum(url_dict[url]['ips'].values())
            for url, data in url_dict.items():
                if 'URL' in dimensions:
                    report.append({
                        'Id': id,
                        'Pid': 1,
                        'URL': url,
                        'SourceIP': None,
                        'TimeInterval': None,
                        'Count': data['count']
                    })
                    id += 1
                for ip, ip_count in data['ips'].items():
                    if 'SourceIP' in dimensions:
                        report.append({
                            'Id': id,
                            'Pid': 2,
                            'URL': None,
                            'SourceIP': ip,
                            'TimeInterval': None,
                            'Count': ip_count
                        })
                        id += 1

    # Форматирование отчета
    formatted_report = format_report(report, dimensions)

    # Возвращение отчета в формате JSON
    return jsonify(formatted_report)

# Функция для форматирования отчета
def format_report(report, dimensions):
    # Здесь выполняется форматирование отчета в виде таблицы
    max_length = max(len(item['URL']) for item in report if item['URL']) if 'URL' in dimensions else 0
    max_length = max(max_length, max(len(item['SourceIP']) for item in report if item['SourceIP'])) if 'SourceIP' in dimensions else max_length
    max_length = max(max_length, max(len(item['TimeInterval']) for item in report if item['TimeInterval'])) if 'TimeInterval' in dimensions else max_length
    formatted_report = ["\t\tДетализация".ljust(max_length) + "Количество переходов"]
    for item in report:
        line = "\t" * item['Pid'] if item['Pid'] is not None else ""
        for dimension in dimensions:
            if dimension == 'URL' and item['URL']:
                line += f"{item['URL'].ljust(max_length)}\t"
            elif dimension == 'SourceIP' and item['SourceIP']:
                line += f"{item['SourceIP'].ljust(max_length)}\t"
            elif dimension == 'TimeInterval' and item['TimeInterval']:
                line += f"{item['TimeInterval'].ljust(max_length)}\t"
        if item['Pid'] == None:
            line += "\t" * 2
        elif item['Pid'] == 1:
            line += "\t" * 1
        elif item['Pid'] == 2:
            line += ""
        line += f"{item['Count']}"
        formatted_report.append(line)
    # Возвращение отформатированного отчета
    return '<pre>' + '\n'.join(formatted_report) + '</pre>'

# Обработчик GET-запросов на страницу /get_report
@app.route('/get_report', methods=['GET'])
def get_report():
    # Получение данных из запроса
    dimensions = request.args.get('dimensions').split(',')

    # Отправка POST-запроса на страницу /report
    response = requests.post('http://localhost:5001/report', json={"Dimensions": dimensions})

    # Возвращение ответа от сервера
    return response.json()

# Запуск приложения
if __name__ == '__main__':
    app.run(port=5001, debug=True)
========================================================================================================================================================================================
==========================================================
С
==========================================================
main.c
==========================================================
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include "stack.h"
#include "set.h"
#include "queue.h"
#include "table.h"
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#pragma comment(lib, "ws2_32.lib")
#define PORT 6379 // Определение порта для сервера
#define BACKLOG 10 // Определение максимального количества ожидающих подключений
#define BUFFER_SIZE 104857600 // Определение размера буфера

HANDLE mutex; // Объявление мьютекса
DWORD WINAPI handle_client(LPVOID lpParam); // Объявление функции обработки клиента

int main() {
    WSADATA wsa_data;
    int result = WSAStartup(MAKEWORD(2, 2), &wsa_data); // Инициализация библиотеки сокетов
    SOCKET listen_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // Создание сокета для прослушивания
    struct sockaddr_in server_address; // Структура для хранения адреса сервера
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = htonl(INADDR_ANY);
    server_address.sin_port = htons(PORT);
    result = bind(listen_socket, (struct sockaddr*)&server_address, sizeof(server_address)); // Привязка сокета к адресу
    result = listen(listen_socket, BACKLOG); // Начало прослушивания сокета
    printf("The server is running and waiting for connections on port %d\n", PORT);
    mutex = CreateMutex(NULL, FALSE, NULL); // Создание мьютекса
    while (1) {
        SOCKET client_socket = accept(listen_socket, NULL, NULL); // Принятие подключения от клиента
        CreateThread(NULL, 0, handle_client, (LPVOID)client_socket, 0, NULL); // Создание потока для обработки клиента
    }
    closesocket(listen_socket); // Закрытие сокета прослушивания
    WSACleanup(); // Очистка библиотеки сокетов
    return 0;
}

DWORD WINAPI handle_client(LPVOID lpParam) {
    WaitForSingleObject(mutex, INFINITE); // Получение мьютекса
    SOCKET client_socket = (SOCKET)lpParam; // Получение сокета клиента
    char* buffer = (char*)malloc(BUFFER_SIZE * sizeof(char));
    int bytes_received;
    // Получение данных от клиента, пока клиент не закроет подключение
    while ((bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0)) > 0) {
        buffer[bytes_received] = '\0'; // Добавление нуль-терминатора
        // Удаление символов возврата каретки и новой строки
        for (int i = 0; i < bytes_received; ++i) {
            if (buffer[i] == '\r' || buffer[i] == '\n') {
                buffer[i] = '\0';
                break;
            }
        }
        char** argv = NULL;
        int argc = 0;
        char* token = strtok(buffer, " "); // Разбиение полученных данных на токены
        while (token != NULL) {
            char** temp = realloc(argv, sizeof(char*) * (argc + 1));
            argv = temp;
            argv[argc++] = token;
            token = strtok(NULL, " ");
        }
        // Обработка полученных данных и выполнение соответствующих операций
        char* filename = NULL; // Имя файла
        char* query = NULL;
        char* key = NULL; // Ключ (Объект)
        char* basename = NULL; // Имя БД
        char* item = NULL; // Объект
        int temp; // Переменная, отвечающая за номер аргумента
        char* result = NULL;
        // Проверка количества аргументов
        if (argc < 4 || argc > 7) {
            result = malloc(100);
            sprintf(result, "Error.\n");
            goto skip;
        }
        // Цикл по аргументам
        for (int i = 0; i < argc; i++) {
            if (strcmp(argv[i], "--file") == 0 && i + 1 < argc) {
                filename = argv[i + 1];
            }
            else if (strcmp(argv[i], "--query") == 0 && i + 1 < argc) {
                query = argv[i + 1];
                temp = i + 1;
                basename = argv[i + 2];
                if (i + 5 > argc) key = argv[i + 3];
                else {
                    item = argv[i + 3];
                    key = argv[i + 4];
                    // Проверка наличия ключа и элемента
                    if (key == NULL || item == NULL) {
                        result = malloc(100);
                        sprintf(result, "Error.\n");
                        goto skip;
                    }
                }
            }
        }
        int pos1 = 0; // Переменная, отвечающая за позицию начала строки.
        int pos2 = 0; // Переменная, отвечающая за позицию конца строки.
        int status = 0; // Переменная-переключатель.
        // Обработка каждой команды
        if (filename != NULL && query != NULL) {
            FILE* file = fopen(filename, "r");
        if (!file) {
            FILE* file = fopen(filename, "w");
        }
        if (strcmp(argv[temp], "SPUSH") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            Stack* stack = loadFromFileStack(filename, basename, &pos1, &pos2, &status);
            if (stack == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    SPUSH(stack, key);
                    result = malloc(strlen(key) + 5);
                    sprintf(result, "-> %s\n", key);
                    if (status == 1) status = 0;
                    fclose(file);
                    saveToFileStack(stack, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "SPOP") == 0) {
            Stack* stack = loadFromFileStack(filename, basename, &pos1, &pos2, &status);
            if (stack == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(40);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    char* element = SPOP(stack);
                    result = malloc(strlen(element) + 5);
                    sprintf(result, "-> %s\n", element);
                    if (status == 2) status = 0;
                    fclose(file);
                    saveToFileStack(stack, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "SADD") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            Set* set = loadFromFileSet(filename, basename, &pos1, &pos2, &status);
            if (set == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    SADD(set, key);
                    result = malloc(strlen(key) + 5);
                    sprintf(result, "-> %s\n", key);
                    if (status == 1) status = 0;
                    fclose(file);
                    saveToFileSet(set, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "SREM") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            Set* set = loadFromFileSet(filename, basename, &pos1, &pos2, &status);
            if (set == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    SREM(set, key);
                    result = malloc(strlen(key) + 5);
                    sprintf(result, "-> %s\n", key);
                    if (status == 2) status = 0;
                    fclose(file);
                    saveToFileSet(set, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "SISMEMBER") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            Set* set = loadFromFileSet(filename, basename, &pos1, &pos2, &status);
            if (set == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    result = malloc(100);
                    if (SISMEMBER(set, key)) sprintf(result, "-> True\n");
                    else sprintf(result, "-> False\n");
                    fclose(file);
                }
            }
        }
        if (strcmp(argv[temp], "QPUSH") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            Queue* queue = loadFromFileQueue(filename, basename, &pos1, &pos2, &status);
            if (queue == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    QPUSH(queue, key);
                    result = malloc(strlen(key) + 5);
                    sprintf(result, "-> %s\n", key);
                    if (status == 1) status = 0;
                    fclose(file);
                    saveToFileQueue(queue, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "QPOP") == 0) {
            Queue* queue = loadFromFileQueue(filename, basename, &pos1, &pos2, &status);
            if (queue == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    char* element = QPOP(queue);
                    result = malloc(strlen(element) + 5);
                    sprintf(result, "-> %s\n", element);
                    if (status == 2) status = 0;
                    fclose(file);
                    saveToFileQueue(queue, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "HSET") == 0) {
            if (key == NULL || item == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            HashTable* hashtable = loadFromFileTable(filename, basename, &pos1, &pos2, &status);
            if (hashtable == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    HSET(hashtable, key, item);
                    result = malloc(strlen(item) + strlen(key) + 20);
                    sprintf(result, "-> %s %s\n", item, key);
                    if (status == 1) status = 0;
                    fclose(file);
                    saveToFileTable(hashtable, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "HDEL") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            HashTable* hashtable = loadFromFileTable(filename, basename, &pos1, &pos2, &status);
            if (hashtable == NULL) {
                result = malloc(100);
                sprintf(result, "Error when opening a file!\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Such a database, alas, does not exist!\n");
                    fclose(file);
                }
                else {
                    HDEL(hashtable, key);
                    result = malloc(strlen(key) + 5);
                    sprintf(result, "-> %s\n", key);
                    if (status == 2) status = 0;
                    fclose(file);
                    saveToFileTable(hashtable, filename, basename, &pos1, &pos2, &status);
                }
            }
        }
        if (strcmp(argv[temp], "HGET") == 0) {
            if (key == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                goto skip;
            }
            HashTable* hashtable = loadFromFileTable(filename, basename, &pos1, &pos2, &status);
            if (hashtable == NULL) {
                result = malloc(100);
                sprintf(result, "Error.\n");
                fclose(file);
            }
            else {
                if (pos1 + pos2 == 0) {
                    result = malloc(100);
                    sprintf(result, "Error.\n");
                    fclose(file);
                }
                else {
                    if (HGET(hashtable, key) != NULL) {
                        result = malloc(strlen(HGET(hashtable, key)) + 15);
                        sprintf(result, "%s\n", HGET(hashtable, key));
                    }
                    else {
                        result = malloc(100);
                        sprintf(result, "-> False\n");
                    }
                    fclose(file);
                }
            }
        }
    }
    else {
        result = malloc(100);
        sprintf(result, "Error.\n");
    }
    skip: {
    if (result == NULL) {
        result = malloc(100);
        sprintf(result, "Error.\n");
    }
    int bytes_sent = send(client_socket, result, strlen(result), 0); // Отправка результата клиенту
    }
    free(argv);
    free(result);
    }
    free(buffer);
    closesocket(client_socket); // Закрытие сокета клиента
    ReleaseMutex(mutex); // Освобождение мьютекса
}
==========================================================
queue.c
==========================================================
#define _CRT_SECURE_NO_WARNINGS
#include "queue.h" 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 

// Функция подсчета слов в файле
int countWordsInFileQueue(const char* filename) {
    FILE* file = fopen(filename, "r");
    int count = 0;
    char word[10000];
    while (fscanf(file, "%s", word) != EOF) {
        count++;
    }
    fclose(file);
    return count;
}

// Функция инициализации очереди
Queue* initQueue() {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->front = NULL;  // Установка указателя на начало очереди в NULL
    queue->rear = NULL;  // Установка указателя на конец очереди в NULL
    return queue;   // Возврат указателя на очередь
}

// Функция добавления элемента в очередь
void QPUSH(Queue* queue, char* element) {
    // Новый узел
    NodeQueue* newNode = (NodeQueue*)malloc(sizeof(NodeQueue));
    newNode->element = _strdup(element);  // Копирование элемента в узел
    newNode->next = NULL;  // Установка указателя на следующий узел в NULL
    if (queue->front == NULL) {  // Если очередь пуста
        queue->front = newNode;  // Установка указателя на начало очереди на новый узел
        queue->rear = newNode;  // Установка указателя на конец очереди на новый узел
    }
    else {  // Если очередь не пуста
        queue->rear->next = newNode;  // Добавление нового узла в конец очереди
        queue->rear = newNode;  // Установка указателя на конец очереди на новый узел
    }
}

// Функция удаления элемента из очереди
char* QPOP(Queue* queue) {
    // Проверка пустоты очереди
    if (queue->front == NULL) {
        return ("The queue is empty");
    }
    NodeQueue* poppedNode = queue->front;  // Указатель на удаляемый узел
    char* element = poppedNode->element;  // Указатель на удаляемый элемент
    queue->front = poppedNode->next;   // Сдвиг указателя на начало очереди на следующий узел
    if (queue->front == NULL) {  // Если очередь стала пустой
        queue->rear = NULL;  // Установка указателя на конец очереди в NULL
    }
    free(poppedNode);  // Освобождение памяти от удаляемого узла
    return element;  // Возврат указателя на удаляемый элемент
}

// Функция сохранения изменений в файл
void saveToFileQueue(Queue* queue, const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
    FILE* file = fopen(filename, "r");
    FILE* tempFile = fopen("temp.data", "w");
    int ch; // Символ, который требуется записать
    fseek(file, 0, SEEK_SET); // Установка курсора в начало
    fseek(tempFile, 0, SEEK_SET); // Установка курсора в начало
    while ((ch = fgetc(file)) != EOF) { // Цикл, пока не выдаст ошибку при записи
        fputc(ch, tempFile); // Запись символа в поток
        if (ftell(tempFile) == *pos1 - 2 && *status == 2)  // Если пустая БД, то добавляем табуляцию перед элементом
            fprintf(tempFile, "\t%s", queue->front->element);
        else if (ftell(tempFile) == *pos1) {
            NodeQueue* currentNode = queue->front; // Ставим указатель на начало
            // Пока не закончатся добавляем элементы
            while (currentNode != NULL) {
                if (currentNode->next == NULL) // Если нет следующего элемента, то добавляем строку
                    fprintf(tempFile, "%s\n", currentNode->element);
                else // Иначе добавляем после элемента табуляцию
                    fprintf(tempFile, "%s\t", currentNode->element);
                currentNode = currentNode->next; // Переход к следующему элементу
            }
            // Добавление новую строку, если БД пуста
            if (*status == 1) {
                fseek(tempFile, *pos1 - 1, SEEK_SET);
                fprintf(tempFile, "\n");
            }
            fseek(file, *pos2, SEEK_SET);
        }
    }
    NodeQueue* currentNode = queue->front;
    while (currentNode != NULL) {
        NodeQueue* nextNode = currentNode->next;
        free(currentNode->element);
        free(currentNode);
        currentNode = nextNode;
    }
    free(queue);
    fclose(file);
    fclose(tempFile);
    remove(filename);
    rename("temp.data", filename);
}

// Функция загрузки БД в структуру
Queue* loadFromFileQueue(const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
    FILE* file = fopen(filename, "r");
    // Проверка наличия файла
    if (file == NULL) {
        return NULL;
    }
    int num_lines = countWordsInFileQueue(filename); // Переменная, отвечающая за количество слов
    char** line = malloc(num_lines * sizeof(char*));
    for (int i = 0; i < num_lines; i++) line[i] = malloc(10000 * sizeof(char));
    Queue* queue = initQueue();
    int tempory = 0; // Переменная-переключатель
    int pos3 = 0; // Временная переменная, которая запоминает исходную позицию курсора
    int temp1 = 0; // Переменная, отвечающая за номер 1 элемента в БД
    int temp2 = 0; // Переменная, отвечающая за номер 2 элемента в БД
    char c = '1'; // Полученный символ
    // Проходимся по всем словам
    for (int i = 0; i < num_lines; ++i) {
        fscanf(file, "%s", line[i]);
        c = getc(file);
        pos3 = ftell(file);
        if (!strcmp(line[i], basename)) { // Если наша БД, то делаем с ней операции
            fseek(file, -3 - strlen(line[i]), SEEK_CUR); // Временно переносим курсор на предыдущии позиции
            if (getc(file) == '\n' || i == 0) {
                fseek(file, pos3, SEEK_SET); // Возврат курсора
                tempory = 1;
                *pos1 = ftell(file);
                temp1 = i + 1;
            }
            else fseek(file, pos3, SEEK_SET); // Возврат курсора
        }
        if (c == '\n' && tempory == 1) { // Конец нашей БД
            temp2 = i;
            *pos2 = ftell(file);
            tempory = 0;
        }
        if (feof(file))
            break;
    }
    if (temp1 == temp2)
        *status = 1; // 1 элемент
    if (temp1 == temp2 + 1)
        *status = 2; // 2 или более элемента
    // Добавление в структуру элементов
    while (temp1 < temp2 + 1) {
        QPUSH(queue, line[temp1]);
        temp1++;
    }
    fclose(file);
    for (int i = 0; i < num_lines; i++) {
        free(line[i]);
    }
    free(line);
    return queue;
}
==========================================================
queue.h
==========================================================
#ifndef QUEUE_H
#define QUEUE_H

typedef struct NodeQueue {
    char* element;
    struct NodeQueue* next;
} NodeQueue;

typedef struct Queue {
    NodeQueue* front;
    NodeQueue* rear;
} Queue;

Queue* initQueue();

void QPUSH(Queue* queue, char* element);

char* QPOP(Queue* queue);

void saveToFileQueue(Queue* queue, const char* filename, const char* basename, int *pos1, int *pos2, int *status);

Queue* loadFromFileQueue(const char* filename, const char* basename, int *pos1, int *pos2, int *status);

#endif
==========================================================
set.c
==========================================================
#define _CRT_SECURE_NO_WARNINGS
#include "set.h" 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#define MAX_SIZE 100000 

// Функция подсчета слов в файле
int countWordsInFileSet(const char* filename) {
    FILE* file = fopen(filename, "r");
    int count = 0;  // Счетчик слов
    char word[10000];  // Массив для хранения слов
    while (fscanf(file, "%s", word) != EOF) {
        count++;
    }
    fclose(file);
    return count;
}

// Функция для инициализации множества
Set* initSet() {
    Set* set = (Set*)malloc(sizeof(Set));
    set->head = NULL; // Инициализация головы множества
    set->size = 0; // Инициализация размера множества
    set->tableSize = MAX_SIZE; // Инициализация размера хеш-таблицы
    set->hashTable = (Node**)malloc(MAX_SIZE * sizeof(Node*));
    set->emptySlots = (int*)malloc(MAX_SIZE * sizeof(int));
    for (int i = 0; i < MAX_SIZE; i++) {
        set->hashTable[i] = NULL; // Инициализация элемента хеш-таблицы
        set->emptySlots[i] = 1; // Инициализация элемента массива пустых слотов
    }
    return set; // Возврат указателя на множество
}

// Функция для вычисления первого хеша
int calculateHashS(const char* element) {
    int hash = 0;
    for (int i = 0; element[i] != '\0'; i++) {
        hash = 31 * hash + element[i];
    }
    return abs(hash) % MAX_SIZE;
}

// Функция для вычисления второго хеша
int calculateHash2S(const char* element) {
    int hash = 0;
    for (int i = 0; element[i] != '\0'; i++) {
        hash = 17 * hash + element[i];
    }
    return abs(hash) % MAX_SIZE;
}

// Функция для добавления элемента в множество
void SADD(Set* set, char* element) {
    int hash = calculateHashS(element); // Вычисление первого хеша элемента
    int step = calculateHash2S(element); // Вычисление второго хеша элемента
    // Объединение хешов
    while (set->hashTable[hash] != NULL && strcmp(set->hashTable[hash]->element, element) != 0) {
        hash = (hash + step) % MAX_SIZE;
    }
    // Проверка повтора элемента
    if (set->hashTable[hash] != NULL && strcmp(set->hashTable[hash]->element, element) == 0) {
        return;
    }
    // Новый узел
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->element = _strdup(element); // Копирование элемента
    newNode->hash = hash; // Сохранение хеша элемента
    newNode->next = set->head; // Установка следующего узла после нового узла
    if (set->head != NULL) { // Если голова множества не пуста
        set->head->prev = newNode; // Установка предыдущего узла
    }
    set->head = newNode; // Обновление головы списка
    set->hashTable[hash] = newNode; // Вставка узла в хеш-таблицу
    set->size++; // Увеличение размера множества
}

// Функция для удаления элемента из множества
void SREM(Set* set, const char* element) {
    int hash = calculateHashS(element); // Вычисление первого хеша элемента
    int step = calculateHash2S(element); // Вычисление второго хеша элемента
    // Объединение хешов
    while (set->hashTable[hash] != NULL && strcmp(set->hashTable[hash]->element, element) != 0) {
        hash = (hash + step) % MAX_SIZE;
    }
    // Если найден элемент
    if (set->hashTable[hash] != NULL && strcmp(set->hashTable[hash]->element, element) == 0) {
        Node* nodeToRemove = set->hashTable[hash]; // Получение узла для удаления
        if (nodeToRemove == set->head) { // Если узел для удаления является головой множества
            set->head = nodeToRemove->next; // Установка следующего узла в качестве головы множества
        }
        else {
            if (nodeToRemove->prev != NULL) { // Если у узла для удаления есть предыдущий узел
                nodeToRemove->prev->next = nodeToRemove->next; // Установка следующего узла после предыдущего узла
            }
        }
        if (nodeToRemove->next != NULL) { // Если у узла для удаления есть следующий узел
            nodeToRemove->next->prev = nodeToRemove->prev; // Установка предыдущего узла перед следующим узлом
        }
        free(nodeToRemove->element); // Освобождение памяти, занятой элементом
        free(nodeToRemove); // Освобождение памяти, занятой узлом
        set->hashTable[hash] = NULL; // Удаление узла из хеш-таблицы
        set->size--; // Уменьшение размера множества на 1
        return;
    }
}

// Функция для проверки существования элемента
int SISMEMBER(Set* set, const char* element) {
    int hash = calculateHashS(element); // Вычисление первого хеша элемента
    int step = calculateHash2S(element); // Вычисление второго хеша элемента
    // Объединение хешов
    while (set->hashTable[hash] != NULL && strcmp(set->hashTable[hash]->element, element) != 0) {
        hash = (hash + step) % MAX_SIZE;
    }
    // Если найден элемент
    if (set->hashTable[hash] != NULL && strcmp(set->hashTable[hash]->element, element) == 0) {
        return 1;
    }
    return 0;
}

// Функция сохранения изменений в файл
void saveToFileSet(Set* set, const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
    FILE* file = fopen(filename, "r");
    FILE* tempFile = fopen("temp.data", "w");
    int ch; // Символ, который требуется записать
    fseek(file, 0, SEEK_SET); // Установка курсора в начало
    fseek(tempFile, 0, SEEK_SET); // Установка курсора в начало
    char** elements = (char**)malloc(set->size * sizeof(char*));
    Node* current = set->head; // Ставим указатель на голову
    int i = 0; // Переменная, отвечающая за порядок
    // Добавление элементов в структуру
    while (current != NULL) {
        elements[i] = current->element;
        current = current->next;
        i++;
    }
    while ((ch = fgetc(file)) != EOF) {  // Цикл, пока не выдаст ошибку при записи
        fputc(ch, tempFile); // Запись символа в поток
        if (ftell(tempFile) == *pos1 - 2 && *status == 2) // Если пустая БД, то добавляем табуляцию перед элементом
            fprintf(tempFile, "\t%s", set->head->element);
        else if (ftell(tempFile) == *pos1) {
            // Пока не закончатся добавляем элементы
            for (int j = set->size - 1; j >= 0; j--) {
                fprintf(tempFile, "%s", elements[j]);
                if (j > 0) // Если есть следующий элемент, то добавляем табуляцию после элемента
                    fprintf(tempFile, "\t");
                else // Иначе добавляем новую строку
                    fprintf(tempFile, "\n");
            }
            // Добавление новую строку, если БД пуста
            if (*status == 1) {
                fseek(tempFile, *pos1 - 1, SEEK_SET);
                fprintf(tempFile, "\n");
            }
            fseek(file, *pos2, SEEK_SET);
        }
    }
    free(elements);
    free(set->hashTable);
    free(set->emptySlots);
    free(set);
    fclose(file);
    fclose(tempFile);
    remove(filename);
    rename("temp.data", filename);
}

// Функция загрузки БД в структуру
Set* loadFromFileSet(const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
    FILE* file = fopen(filename, "r");
    // Проверка наличия файла
    if (file == NULL) {
        return NULL;
    }
    int num_lines = countWordsInFileSet(filename); // Переменная, отвечающая за количество слов
    char** line = malloc(num_lines * sizeof(char*));
    for (int i = 0; i < num_lines; i++) line[i] = malloc(10000 * sizeof(char));
    Set* set = initSet();
    int tempory = 0; // Переменная-переключатель
    int pos3 = 0; // Временная переменная, которая запоминает исходную позицию курсора
    int temp1 = 0; // Переменная, отвечающая за номер 1 элемента в БД
    int temp2 = 0; // Переменная, отвечающая за номер 2 элемента в БД
    char c = '1'; // Полученный символ
    // Проходимся по всем словам
    for (int i = 0; i < num_lines; ++i) {
        fscanf(file, "%s", line[i]);
        c = getc(file);
        pos3 = ftell(file);
        if (!strcmp(line[i], basename)) { // Если наша БД, то делаем с ней операции
            fseek(file, -3 - strlen(line[i]), SEEK_CUR); // Временно переносим курсор на предыдущии позиции
            if (getc(file) == '\n' || i == 0) {
                fseek(file, pos3, SEEK_SET); // Возврат курсора
                tempory = 1;
                *pos1 = ftell(file);
                temp1 = i + 1;
            }
            else fseek(file, pos3, SEEK_SET); // Возврат курсора
        }
        if (c == '\n' && tempory == 1) { // Конец нашей БД
            temp2 = i;
            *pos2 = ftell(file);
            tempory = 0;
        }
        if (feof(file))
            break;
    }
    if (temp1 == temp2)
        *status = 1; // 1 элемент
    if (temp1 == temp2 + 1)
        *status = 2; // 2 или более элемента
    // Добавление в структуру элементов
    while (temp1 < temp2 + 1) {
        SADD(set, line[temp1]);
        temp1++;
    }
    fclose(file);
    for (int i = 0; i < num_lines; i++) {
        free(line[i]);
    }
    free(line);
    return set;
}
==========================================================
set.h
==========================================================
#ifndef SET_H
#define SET_H

typedef struct Node {
    char* element;
    int hash;
    struct Node* next;
    struct Node* prev;
} Node;

typedef struct Set {
    Node* head;
    int size;
    Node** hashTable;
    int tableSize;
    int* emptySlots;
} Set;

Set* initSet();

void SADD(Set* set, char* element);

void SREM(Set* set, char* element);

int SISMEMBER(Set* set, char* element);

void saveToFileSet(Set* set, const char* filename, const char* basename, int *pos1, int *pos2, int *status);

Set* loadFromFileSet(const char* filename, const char* basename, int *pos1, int *pos2, int *status);

#endif
==========================================================
stack.c
==========================================================
#define _CRT_SECURE_NO_WARNINGS
#include "stack.h" 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 

// Функция подсчета слов в файле
int countWordsInFileStack(const char* filename) {
    FILE* file = fopen(filename, "r");
    int count = 0;
    char word[10000];
    while (fscanf(file, "%s", word) != EOF) {
        count++;
    }
    fclose(file);
    return count;
}

// Функция для инициализации стека
Stack* initStack() {
    Stack* stack = (Stack*)malloc(sizeof(Stack));
    stack->top = NULL;
    return stack;
}

// Функция для добавления элемента в стек
void SPUSH(Stack* stack, char* element) {
    NodeStack* newNode = (NodeStack*)malloc(sizeof(NodeStack)); // Выделение памяти под новый узел
    newNode->element = _strdup(element); // Копирование элемента в узел
    newNode->next = stack->top; // Установка следующего узла после нового узла
    stack->top = newNode; // Установка нового узла в качестве вершины стека
}

// Функция для удаления элемента из стека
char* SPOP(Stack* stack) {
    // Проверка пустоты стека
    if (stack->top == NULL) {
        return ("The stack is empty");
    }
    NodeStack* poppedNode = stack->top; // Получение узла для удаления
    stack->top = poppedNode->next; // Установка следующего узла в качестве вершины стека
    char* element = poppedNode->element; // Получение элемента из узла
    free(poppedNode); // Освобождение памяти, занятой узлом
    return element; // Возврат элемента
}

// Функция сохранения изменений в файл
void saveToFileStack(Stack* stack, const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
    FILE* file = fopen(filename, "r");
    FILE* tempFile = fopen("temp.data", "w");
    int ch; // Символ, который требуется записать
    fseek(file, 0, SEEK_SET); // Установка курсора в начало
    fseek(tempFile, 0, SEEK_SET); // Установка курсора в начало
    while ((ch = fgetc(file)) != EOF) { // Цикл, пока не выдаст ошибку при записи
        fputc(ch, tempFile); // Запись символа в поток
        if (ftell(tempFile) == *pos1 - 2 && *status == 2)  // Если пустая БД, то добавляем табуляцию перед элементом
            fprintf(tempFile, "\t%s", stack->top->element);
        else if (ftell(tempFile) == *pos1) {
            NodeStack* currentNode = stack->top; // Ставим указатель на вершину стека
            NodeStack* prevNode = NULL; // Временная переменная-указатель
            // Цикл для перевёртывания стека
            while (currentNode != NULL) {
                NodeStack* nextNode = currentNode->next;
                currentNode->next = prevNode;
                prevNode = currentNode;
                currentNode = nextNode;
            }
            currentNode = prevNode;
            while (currentNode != NULL) { // Цикл пока не закончатся элементы
                if (currentNode->next == NULL)
                    fprintf(tempFile, "%s\n", currentNode->element); // Если нет следующего элемента, то добавляем строку
                else // Иначе добавляем после элемента табуляцию
                    fprintf(tempFile, "%s\t", currentNode->element);
                currentNode = currentNode->next;
            }
            // Добавление новую строку, если БД пуста
            if (*status == 1) {
                fseek(tempFile, *pos1 - 1, SEEK_SET);
                fprintf(tempFile, "\n");
            }
            fseek(file, *pos2, SEEK_SET);
        }
    }
    free(stack->top);
    free(stack);
    fclose(file);
    fclose(tempFile);
    remove(filename);
    rename("temp.data", filename);
}

// Функция загрузки БД в структуру
Stack* loadFromFileStack(const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
    FILE* file = fopen(filename, "r");
    // Проверка наличия файла
    if (file == NULL) {
        return NULL;
    }
    int num_lines = countWordsInFileStack(filename); // Переменная, отвечающая за количество слов
    char** line = malloc(num_lines * sizeof(char*));
    for (int i = 0; i < num_lines; i++) line[i] = malloc(10000 * sizeof(char));
    Stack* stack = initStack();
    int tempory = 0; // Переменная-переключатель
    int pos3 = 0; // Временная переменная, которая запоминает исходную позицию курсора
    int temp1 = 0; // Переменная, отвечающая за номер 1 элемента в БД
    int temp2 = 0; // Переменная, отвечающая за номер 2 элемента в БД
    char c = '1'; // Полученный символ
    // Проходимся по всем словам
    for (int i = 0; i < num_lines; ++i) {
        fscanf(file, "%s", line[i]);
        c = getc(file);
        pos3 = ftell(file);
        if (!strcmp(line[i], basename)) { // Если наша БД, то делаем с ней операции
            fseek(file, -3 - strlen(line[i]), SEEK_CUR); // Временно переносим курсор на предыдущии позиции
            if (getc(file) == '\n' || i == 0) {
                fseek(file, pos3, SEEK_SET); // Возврат курсора
                tempory = 1;
                *pos1 = ftell(file);
                temp1 = i + 1;
            }
            else fseek(file, pos3, SEEK_SET); // Возврат курсора
        }
        if (c == '\n' && tempory == 1) { // Конец нашей БД
            temp2 = i;
            *pos2 = ftell(file);
            tempory = 0;
        }
        if (feof(file))
            break;
    }
    if (temp1 == temp2)
        *status = 1; // 1 элемент
    if (temp1 == temp2 + 1)
        *status = 2; // 2 или более элемента
    // Добавление в структуру элементов
    while (temp1 < temp2 + 1) {
        SPUSH(stack, line[temp1]);
        temp1++;
    }
    fclose(file);
    for (int i = 0; i < num_lines; i++) {
        free(line[i]);
    }
    free(line);
    return stack;
}
==========================================================
stack.h
==========================================================
#ifndef STACK_H
#define STACK_H

typedef struct NodeStack {
    char* element;
    struct NodeStack* next;
} NodeStack;

typedef struct Stack {
    NodeStack* top;
} Stack;

Stack* initStack();

void SPUSH(Stack* stack, char* element);

char* SPOP(Stack* stack);

void saveToFileStack(Stack* stack, const char* filename, const char* basename, int *pos1, int *pos2, int *status);

Stack* loadFromFileStack(const char* filename, const char* basename, int *pos1, int *pos2, int *status);

#endif
==========================================================
table.c
==========================================================
#define _CRT_SECURE_NO_WARNINGS
#include "table.h" 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#define MAX_SIZE 100000

// Функция подсчета слов в файле
int countWordsInFileTable(const char* filename) {
	FILE* file = fopen(filename, "r");
	int count = 0;
	char word[10000];
	while (fscanf(file, "%s", word) != EOF) {
		count++;
	}
	fclose(file);
	return count;
}

// Функция для инициализации хеш-таблицы
HashTable* initHashTable() {
	HashTable* ht = (HashTable*)malloc(sizeof(HashTable));
	ht->head = NULL;
	ht->size = 0;
	ht->tableSize = MAX_SIZE;
	ht->hashTable = (NodeHashTable**)malloc(MAX_SIZE * sizeof(NodeHashTable*));
	ht->keys = (char**)malloc(MAX_SIZE * sizeof(char*));
	for (int i = 0; i < MAX_SIZE; i++) {
		ht->hashTable[i] = NULL;
		ht->keys[i] = NULL;
	}
	return ht;
}

// Функция для вычисления хеша
int calculateHashT(const char* element) {
	int hash = 0;
	for (int i = 0; element[i] != '\0'; i++) {
		hash = 31 * hash + element[i];
	}
	return abs(hash) % MAX_SIZE;
}

// Функция для добавления элемента в хеш-таблицу
void HSET(HashTable* ht, char* key, char* value) {
	int hash = calculateHashT(key); // Вычисление хеша ключа
	NodeHashTable* current = ht->hashTable[hash];
	// Проверка уникальности ключа
	while (current != NULL) {
		if (strcmp(current->key, key) == 0) {
			return;
		}
		current = current->next;
	}
	// Новый узел
	NodeHashTable* newNode = (NodeHashTable*)malloc(sizeof(NodeHashTable));
	newNode->key = _strdup(key); // Сохранение ключа в узле
	newNode->element = _strdup(value); // Копирование элемента в узел
	newNode->hash = hash; // Сохранение хеша в узле
	newNode->next = NULL; // Инициализация следующего узла как NULL
	newNode->prev = NULL; // Инициализация предыдущего узла как NULL
	if (ht->hashTable[hash] == NULL) { // Если список для данного хеша пуст
		ht->hashTable[hash] = newNode; // Установка нового узла как первого в списке
	}
	else {
		current = ht->hashTable[hash]; // Начало списка
		while (current->next != NULL) { // Поиск последнего узла в списке
			current = current->next;
		}
		current->next = newNode; // Добавление нового узла в конец списка
		newNode->prev = current; // Установка предыдущего узла для нового узла
	}
	ht->size++; // Увеличение размера хеш-таблицы
	ht->keys[ht->size - 1] = _strdup(key); // Сохранение ключа в массиве ключей
}

// Функция для получения элемента из хеш-таблицы
char* HGET(HashTable* ht, const char* key) {
	int hash = calculateHashT(key); // Вычисление хеша ключа
	NodeHashTable* current = ht->hashTable[hash];
	// Поиск элемента по ключу с учетом коллизий
	while (current != NULL) {
		if (strcmp(current->key, key) == 0) { // Сравнение ключей
			return current->element;
		}
		current = current->next; // Переход к следующему узлу в случае коллизии
	}
	return NULL;
}

// Функция для удаления элемента из хеш-таблицы
void HDEL(HashTable* ht, const char* key) {
	int hash = calculateHashT(key); // Вычисление хеша ключа
	NodeHashTable* current = ht->hashTable[hash];
	NodeHashTable* nodeToRemove = NULL;
	// Поиск элемента по ключу с учетом коллизий
	while (current != NULL) {
		if (strcmp(current->key, key) == 0) { // Сравнение ключей
			nodeToRemove = current; // Если ключи совпадают, помечаем узел для удаления
			break;
		}
		current = current->next; // Переход к следующему узлу в случае коллизии
	}
	// Если узел найден, удаляем его
	if (nodeToRemove != NULL) {
		if (nodeToRemove->prev != NULL) { // Если у узла есть предыдущий узел
			nodeToRemove->prev->next = nodeToRemove->next; // Удаление узла из списка
		}
		if (nodeToRemove->next != NULL) { // Если у узла есть следующий узел
			nodeToRemove->next->prev = nodeToRemove->prev; // Удаление узла из списка
		}
		if (nodeToRemove == ht->hashTable[hash]) { // Если узел является первым в списке
			ht->hashTable[hash] = nodeToRemove->next; // Обновление начала списка
		}
		free(nodeToRemove->key); // Освобождение памяти ключа
		free(nodeToRemove->element); // Освобождение памяти элемента
		free(nodeToRemove); // Освобождение памяти узла
		ht->size--; // Уменьшение размера хеш-таблицы
	}
}

// Функция сохранения изменений в файл
void saveToFileTable(HashTable* hashtable, const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
	FILE* file = fopen(filename, "r");
	FILE* tempFile = fopen("temp.data", "w");
	int ch; // Символ, который требуется записать
	fseek(file, 0, SEEK_SET); // Установка курсора в начало
	fseek(tempFile, 0, SEEK_SET); // Установка курсора в начало
	while ((ch = fgetc(file)) != EOF) { // Цикл, пока не выдаст ошибку при записи
		fputc(ch, tempFile); // Запись символа в поток
		if (ftell(tempFile) == *pos1 - 2 && *status == 2) { // Если пустая БД, то добавляем табуляцию перед элементом с ключом
			fprintf(tempFile, "\t%s\t%s", hashtable->hashTable[calculateHashT(hashtable->keys[0])]->element, hashtable->keys[0]);
		}
		else if (ftell(tempFile) == *pos1) {
			// Проходимся по всем элементам
			for (int i = 0; i < hashtable->size; i++) {
				if (i == hashtable->size - 1) { // Если нет следующего элемента с ключом, то добавляем строку
					fprintf(tempFile, "%s\t%s\n", hashtable->hashTable[calculateHashT(hashtable->keys[i])]->element, hashtable->keys[i]);
				}
				else { // Иначе добавляем после элемента с ключом табуляцию
					fprintf(tempFile, "%s\t%s\t", hashtable->hashTable[calculateHashT(hashtable->keys[i])]->element, hashtable->keys[i]);
				}
			}
			// Добавление новую строку, если БД пуста
			if (*status == 1) {
				fseek(tempFile, *pos1 - 1, SEEK_SET);
				fprintf(tempFile, "\n");
			}
			fseek(file, *pos2, SEEK_SET);
		}
	}
	free(hashtable->hashTable);
	free(hashtable->keys);
	free(hashtable);
	fclose(file);
	fclose(tempFile);
	remove(filename);
	rename("temp.data", filename);
}

// Функция загрузки БД в структуру
HashTable* loadFromFileTable(const char* filename, const char* basename, int* pos1, int* pos2, int* status) {
	FILE* file = fopen(filename, "r");
	int num_lines = countWordsInFileTable(filename); // Переменная, отвечающая за количество слов
	char** line = malloc(num_lines * sizeof(char*));
	for (int i = 0; i < num_lines; i++) line[i] = malloc(10000 * sizeof(char));
	HashTable* hashtable = initHashTable();
	int tempory = 0; // Переменная-переключатель
	int tempory2 = 0; // Переменная, временно хранящие положение символа
	int temp1 = 0; // Переменная, отвечающая за номер 1 элемента в БД
	int temp2 = 0; // Переменная, отвечающая за номер 2 элемента в БД
	char c = '1'; // Полученный символ
	// Проходимся по всем словам
	for (int i = 0; i < num_lines; ++i) {
		fscanf(file, "%s", line[i]);
		c = getc(file);
		if (c == '\n') {
			tempory2 = ftell(file);
		}
		if (!strcmp(line[i], basename) && (tempory2 == ftell(file) || tempory2 == ftell(file) - strlen(line[i]) - 1 || i == 0)) { // Если наша БД, то делаем с ней операции
			tempory = 1;
			*pos1 = ftell(file);
			*pos2 = strlen(line[i]);
			temp1 = i + 1;
		}
		if (c == '\n' && tempory == 1) { // Конец нашей БД
			temp2 = i;
			*pos2 = ftell(file);
			tempory = 0;
		}
		if (feof(file))
			break;
	}
	if (temp1 + 1 == temp2) *status = 1; // 1 элемент
	if (temp1 == temp2 + 1) *status = 2; // 2 или более элемента
	// Добавление в структуру элементов
	while (temp1 < temp2) {
		char* value = line[temp1];
		char* key = line[temp1 + 1];
		HSET(hashtable, key, value);
		temp1 += 2;
	}
	fclose(file);
	for (int i = 0; i < num_lines; i++) {
		free(line[i]);
	}
	free(line);
	return hashtable;
}
==========================================================
table.h
==========================================================
#ifndef TABLE_H
#define TABLE_H

typedef struct NodeHashTable {
    char* key;
    char* element;
    int hash;
    struct NodeHashTable* next;
    struct NodeHashTable* prev;
} NodeHashTable;

typedef struct HashTable {
    NodeHashTable* head;
    int size;
    NodeHashTable** hashTable;
    int tableSize;
    char** keys;
} HashTable;

HashTable* initHashTable();

void HSET(HashTable* hashtable, char* key, char* value);

void HDEL(HashTable* hashtable, char* key);

char* HGET(HashTable* hashtable, char* key);

void saveToFileTable(HashTable* hashtable, const char* filename, const char* basename, int *pos1, int *pos2, int *status);

HashTable* loadFromFileTable(const char* filename, const char* basename, int *pos1, int *pos2, int *status);

#endif
==========================================================
Python
==========================================================
Servis1.py
==========================================================
import string
import random
import socket
from flask import Flask, request, redirect
from flask_cors import CORS
import time
import requests
import datetime

app = Flask(__name__)  # Создание экземпляра приложения Flask
CORS(app)  # Разрешение CORS для всего приложения

# Декоратор для обработки GET-запроса по пути '/form'
@app.route('/form', methods=['GET'])
def form():
    # Возвращает HTML-форму для ввода URL
    return '''
    <!DOCTYPE html>
<html>
<body>

<h2>Сокращения URL</h2>

<form id="myForm">
  <label for="url">Введите URL:</label><br>
  <input type="text" id="url" name="url"><br>
  <input type="submit" value="Сократить URL">
</form> 

<p id="shortUrl"></p>

<script>
document.getElementById('myForm').addEventListener('submit', function(e) {
  e.preventDefault();
  var url = document.getElementById('url').value;
  if(url.trim() === '') {
    document.getElementById('shortUrl').innerText = 'Пожалуйста, введите URL';
    return;
  }
  if(new Blob([url]).size > 50000) {
    document.getElementById('shortUrl').innerText = 'URL не должен превышать 50000 байт';
    return;
  }
  fetch('/', {
    method: 'POST',
    headers: {
      'Content-Type': 'text/plain'
    },
    body: url
  }).then(function(response) {
    if (!response.ok) {
      throw new Error('Ошибка сети при попытке сократить URL');
    }
    return response.text();
  }).then(function(text) {
    if (text === 'Error.') {
      document.getElementById('shortUrl').innerText = 'Произошла ошибка при обработке вашего запроса';
    } else {
      document.getElementById('shortUrl').innerText = 'Ваш сокращенный URL: ' + text;
    }
  }).catch(function(error) {
    document.getElementById('shortUrl').innerText = 'Произошла ошибка: ' + error.message;
  });
});
</script>

</body>
</html>
    '''

# Функция для генерации короткого URL
def generate_short_url():
    return ''.join(random.choices(string.ascii_letters + string.digits, k=8))

# Декоратор для обработки POST-запроса по корневому пути '/'
@app.route('/', methods=['POST'])
def shorten_url():
    # Получение данных из запроса и декодирование
    url = request.data.decode()
    # Создание сокета для подключения к серверу
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            # Попытка подключения к серверу
            s.connect((SERVER_IP, SERVER_PORT))
        except Exception as e:
            # В случае ошибки возвращается сообщение об ошибке
            return f'Не удалось подключиться к серверу: {str(e)}', 500
        # Отправка запроса на получение существующего короткого URL
        s.sendall(f'--file urls.data --query HGET short_urls {url}'.encode())
        # Получение ответа от сервера
        existing_url = s.recv(1024).decode()
        existing_url = existing_url.replace('\n', '').replace('\r', '')
        # Обработка ошибки или возврат существующего короткого URL
        if existing_url == "Error.":
            s.close()
            return 'Error.', 501
        if existing_url != "-> False":
            s.close()
            return f'{request.url_root}SU/{existing_url}'
        # Генерация нового короткого URL, если существующего нет
        while True:
            short_url = generate_short_url()
            s.sendall(f'--file urls.data --query HGET urls {short_url}'.encode())
            existing_url = s.recv(1024).decode()
            existing_url = existing_url.replace('\n', '').replace('\r', '')
            if existing_url == "Error.":
                s.close()
                return 'Error.', 502
            if existing_url == "-> False":
                s.sendall(f'--file urls.data --query HSET urls {url} {short_url}'.encode())
                if s.recv(1024).decode().replace('\n', '').replace('\r', '') == "Error.":
                    s.close()
                    return 'Error.', 503
                s.sendall(f'--file urls.data --query HSET short_urls {short_url} {url}'.encode())
                if s.recv(1024).decode().replace('\n', '').replace('\r', '') == "Error.":
                    s.close()
                    return 'Error.', 504
                s.close()
                return f'{request.url_root}SU/{short_url}'

# Декоратор для обработки GET-запроса по пути '/SU/<short_url>'
@app.route('/SU/<short_url>', methods=['GET'])
def redirect_url(short_url):
    # Создание сокета для подключения к серверу
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            # Попытка подключения к серверу
            s.connect((SERVER_IP, SERVER_PORT))
        except Exception as e:
            # В случае ошибки возвращается сообщение об ошибке
            return f'Не удалось подключиться к серверу: {str(e)}', 505
        # Отправка запроса на получение оригинального URL
        s.sendall(f'--file urls.data --query HGET urls {short_url}'.encode())
        # Получение ответа от сервера
        url = s.recv(1024).decode()
        url = url.replace('\n', '').replace('\r', '')
        # Обработка ошибки или перенаправление на оригинальный URL
        if url == "Error.":
            s.close()
            return 'Error.', 500
        s.close()
    # Отправка данных для JSON
    response = requests.post(f'http://{SERVER_IP_PORT}/', json={
        'ip': request.headers.get('X-Forwarded-For', request.remote_addr),
        'url': f'{url}_({short_url})',
        'timestamp': datetime.datetime.now().replace(second=0).replace(microsecond=0).isoformat().replace('T', '_')[:-3]
    })
    if response.status_code == 204:
        print("Запрос успешно обработан.")
    else:
        print(f"Произошла ошибка: {response.status_code}")
    return redirect(url, code=302)

if __name__ == '__main__':
    SERVER_IP_PORT = input("Введите IP-адрес и порт сервера статистики (формат: myip:myport): ")
    SERVER_IP, SERVER_PORT = input("Введите IP-адрес и порт сервера СУБД (формат: myip:myport): ").split(':')
    SERVER_PORT = int(SERVER_PORT)
    app.run(debug=True)
==========================================================
Servis2.py
==========================================================
import string
from flask import Flask, request, jsonify
import datetime
import socket
import requests
import json

# Класс для сбора и обработки статистики.
class Statistics:
    # Инициализация класса с запросом IP-адреса и порта сервера.
    def __init__(self):
        self.SERVER_IP, self.SERVER_PORT = input("Введите IP-адрес и порт сервера СУБД (формат: myip:myport): ").split(':')
        self.SERVER_PORT = int(self.SERVER_PORT)
        # Словари для хранения статистики.
        self.statistics1 = {}
        self.statistics2 = {}
        self.statistics3 = {}
        self.statistics4 = {}
        self.statistics5 = {}
        self.statistics6 = {}
        self.count_tik = 0 # Счетчик для итерации данных.
        
    # Метод для загрузки и обновления статистики.
    def load(self):
        # Очистка словарей перед загрузкой новых данных.
        self.statistics1.clear()
        self.statistics2.clear()
        self.statistics3.clear()
        self.statistics4.clear()
        self.statistics5.clear()
        self.statistics6.clear()
        self.count_tik = 0 # Сброс счетчика.
        last_ip = ""  # Последний известный IP-адрес.
        last_url = ""  # Последний известный URL.
        # Бесконечный цикл для получения данных до прерывания.
        while True:
            self.count_tik = self.count_tik + 1
            # Создание сокета для подключения к серверу.
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                try:
                    s.connect((self.SERVER_IP, self.SERVER_PORT))
                except Exception as e:
                    print (f'Не удалось подключиться к серверу: {str(e)}')
                # Отправка запроса на сервер для получения IP-адреса.
                s.sendall(f'--file urls.data --query HGET ip {self.count_tik}'.encode())
                ip = s.recv(1024).decode()
                ip = ip.replace('\n', '').replace('\r', '')
                if ip == "Error.":
                    print ('Error.')
                if ip == "-> False":
                    ip = last_ip # Если данных нет, используется последний известный IP.
                last_ip = ip
            # Аналогично для получения URL.
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                try:
                    s.connect((self.SERVER_IP, self.SERVER_PORT))
                except Exception as e:
                    print (f'Не удалось подключиться к серверу: {str(e)}')
                s.sendall(f'--file urls.data --query HGET url {self.count_tik}'.encode())
                url = s.recv(1024).decode()
                url = url.replace('\n', '').replace('\r', '')
                if url == "Error.":
                    print ('Error.')
                if url == "-> False":
                    url = last_url
                last_url = url
            # Аналогично для получения времени.
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                try:
                    s.connect((self.SERVER_IP, self.SERVER_PORT))
                except Exception as e:
                    print (f'Не удалось подключиться к серверу: {str(e)}')
                s.sendall(f'--file urls.data --query HGET timestamp {self.count_tik}'.encode())
                timestamp = s.recv(1024).decode()
                timestamp = timestamp.replace('\n', '').replace('\r', '')
                if timestamp == "Error.":
                    print ('Error.')
                if timestamp == "-> False":
                    break
            # Обновление словарей статистики данными.
            if url not in self.statistics1:
                self.statistics1[url] = []
            self.statistics1[url].append((ip, timestamp))
            if url not in self.statistics2:
                self.statistics2[url] = []
            self.statistics2[url].append((timestamp, ip))
            if ip not in self.statistics3:
                self.statistics3[ip] = []
            self.statistics3[ip].append((url, timestamp))
            if ip not in self.statistics4:
                self.statistics4[ip] = []
            self.statistics4[ip].append((timestamp, url))
            if timestamp not in self.statistics5:
                self.statistics5[timestamp] = []
            self.statistics5[timestamp].append((ip, url))
            if timestamp not in self.statistics6:
                self.statistics6[timestamp] = []
            self.statistics6[timestamp].append((url, ip))

    # Метод для отправки статистики на сервер.
    def post_statistics(self, ip, url, timestamp):
        self.load()
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.connect((self.SERVER_IP, self.SERVER_PORT))
            except Exception as e:
                return f'Не удалось подключиться к серверу: {str(e)}', 500
            s.sendall(f'--file urls.data --query HSET ip {ip} {self.count_tik}'.encode())
            if s.recv(1024).decode().replace('\n', '').replace('\r', '') == "Error.":
                return 'Error.', 500
            s.close()
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.connect((self.SERVER_IP, self.SERVER_PORT))
            except Exception as e:
                return f'Не удалось подключиться к серверу: {str(e)}', 500
            s.sendall(f'--file urls.data --query HSET url {url} {self.count_tik}'.encode())
            if s.recv(1024).decode().replace('\n', '').replace('\r', '') == "Error.":
                return 'Error.', 500
            s.close()
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.connect((self.SERVER_IP, self.SERVER_PORT))
            except Exception as e:
                return f'Не удалось подключиться к серверу: {str(e)}', 500
            s.sendall(f'--file urls.data --query HSET timestamp {timestamp} {self.count_tik}'.encode())
            if s.recv(1024).decode().replace('\n', '').replace('\r', '') == "Error.":
                return 'Error.', 500
            s.close()
        if url not in self.statistics1:
            self.statistics1[url] = []
        self.statistics1[url].append((ip, timestamp))
        if url not in self.statistics2:
            self.statistics2[url] = []
        self.statistics2[url].append((timestamp, ip))
        if ip not in self.statistics3:
            self.statistics3[ip] = []
        self.statistics3[ip].append((url, timestamp))
        if ip not in self.statistics4:
            self.statistics4[ip] = []
        self.statistics4[ip].append((timestamp, url))
        if timestamp not in self.statistics5:
            self.statistics5[timestamp] = []
        self.statistics5[timestamp].append((ip, url))
        if timestamp not in self.statistics6:
            self.statistics6[timestamp] = []
        self.statistics6[timestamp].append((url, ip))
        return '', 204

    # Метод для создания отчета по заданным параметрам.
    def report(self, dimensions):
        self.load()
        report = []
        id = 1
        if len(dimensions) == 1:
            dimension = dimensions[0]
            if dimension == 'URL':
                for url, stats in self.statistics1.items():
                    report.append({
                        'Id': id,
                        'Pid': None,
                        'URL': url,
                        'SourceIP': None,
                        'TimeInterval': None,
                        'Count': len(stats)
                    })
                    id += 1
            elif dimension == 'SourceIP':
                for ip, stats in self.statistics3.items():
                    report.append({
                        'Id': id,
                        'Pid': None,
                        'URL': None,
                        'SourceIP': ip,
                        'TimeInterval': None,
                        'Count': len(stats)
                    })
                    id += 1
            elif dimension == 'TimeInterval':
                for timestamp, stats in self.statistics5.items():
                    report.append({
                        'Id': id,
                        'Pid': None,
                        'URL': None,
                        'SourceIP': None,
                        'TimeInterval': str(timestamp),
                        'Count': len(stats)
                    })
        else:
            if (dimensions[0]=='URL' and dimensions[1]=='SourceIP'):
                for url, stats in self.statistics1.items():
                    url_dict = {}
                    for stat in stats:
                        ip, timestamp = stat
                        if ip not in url_dict:
                            url_dict[ip] = {'count': 1, 'timestamps': {timestamp: 1}}
                        else:
                            if timestamp not in url_dict[ip]['timestamps']:
                                url_dict[ip]['timestamps'][timestamp] = 1
                            else:
                                url_dict[ip]['timestamps'][timestamp] += 1
                    total_count = sum(sum(data['timestamps'].values()) for data in url_dict.values())
                    report.append({
                        'Id': id,
                        'Pid': None,
                        'URL': url,
                        'SourceIP': None,
                        'TimeInterval': None,
                        'Count': total_count
                    })
                    id += 1
                    for ip, data in url_dict.items():
                        if 'SourceIP' in dimensions:
                            report.append({
                                'Id': id,
                                'Pid': 1,
                                'URL': None,
                                'SourceIP': ip,
                                'TimeInterval': None,
                                'Count': sum(data['timestamps'].values())
                            })
                            id += 1
                        for timestamp, timestamp_count in data['timestamps'].items():
                            if 'TimeInterval' in dimensions:
                                report.append({
                                    'Id': id,
                                    'Pid': 2,
                                    'URL': None,
                                    'SourceIP': None,
                                    'TimeInterval': str(timestamp),
                                    'Count': timestamp_count
                                })
                                id += 1
            if (dimensions[0]=='URL' and dimensions[1]=='TimeInterval'):
                for url, stats in self.statistics2.items():
                    url_dict = {}
                    for stat in stats:
                        timestamp, ip = stat
                        if timestamp not in url_dict:
                            url_dict[timestamp] = {'count': 1, 'ips': {ip: 1}}
                        else:
                            if ip not in url_dict[timestamp]['ips']:
                                url_dict[timestamp]['ips'][ip] = 1
                            else:
                                url_dict[timestamp]['ips'][ip] += 1
                    total_count = sum(sum(data['ips'].values()) for data in url_dict.values())
                    report.append({
                        'Id': id,
                        'Pid': None,
                        'URL': url,
                        'SourceIP': None,
                        'TimeInterval': None,
                        'Count': total_count
                    })
                    id += 1
                    for timestamp, data in url_dict.items():
                        if 'TimeInterval' in dimensions:
                            report.append({
                                'Id': id,
                                'Pid': 1,
                                'URL': None,
                                'SourceIP': None,
                                'TimeInterval': str(timestamp),
                                'Count': sum(data['ips'].values())
                            })
                            id += 1
                        for ip, ip_count in data['ips'].items():
                            if 'SourceIP' in dimensions:
                                report.append({
                                    'Id': id,
                                    'Pid': 2,
                                    'URL': None,
                                    'SourceIP': ip,
                                    'TimeInterval': None,
                                    'Count': ip_count
                                })
                                id += 1
            if (dimensions[0]=='SourceIP' and dimensions[1]=='URL'):
                for ip, stats in self.statistics3.items():
                    ip_dict = {}
                    for stat in stats:
                        url, timestamp = stat
                        if url not in ip_dict:
                            ip_dict[url] = {'count': 1, 'timestamps': {timestamp: 1}}
                        else:
                            if timestamp not in ip_dict[url]['timestamps']:
                                ip_dict[url]['timestamps'][timestamp] = 1
                            else:
                                ip_dict[url]['timestamps'][timestamp] += 1
                    total_count = sum(sum(data['timestamps'].values()) for data in ip_dict.values())
                    report.append({
                        'Id': id,
                        'Pid': None,
                        'URL': None,
                        'SourceIP': ip,
                        'TimeInterval': None,
                        'Count': total_count
                    })
                    id += 1
                    for url, data in ip_dict.items():
                        if 'URL' in dimensions:
                            report.append({
                                'Id': id,
                                'Pid': 1,
                                'URL': url,
                                'SourceIP': None,
                                'TimeInterval': None,
                                'Count': sum(data['timestamps'].values())
                            })
                            id += 1
                        for timestamp, timestamp_count in data['timestamps'].items():
                            if 'TimeInterval' in dimensions:
                                report.append({
                                    'Id': id,
                                    'Pid': 2,
                                    'URL': None,
                                    'SourceIP': None,
                                    'TimeInterval': str(timestamp),
                                    'Count': timestamp_count
                                })
                                id += 1
            if (dimensions[0]=='SourceIP' and dimensions[1]=='TimeInterval'):
                for ip, stats in self.statistics4.items():
                    report.append({
                        'Id': id,
                        'Pid': None,
                        'URL': None,
                        'SourceIP': ip,
                        'TimeInterval': None,
                        'Count': len(stats)
                    })
                    id += 1
                    timestamp_dict = {}
                    for stat in stats:
                        timestamp, url = stat
                        if timestamp not in timestamp_dict:
                            timestamp_dict[timestamp] = {'count': 1, 'urls': {url: 1}}
                        else:
                            timestamp_dict[timestamp]['count'] += 1
                            if url not in timestamp_dict[timestamp]['urls']:
                                timestamp_dict[timestamp]['urls'][url] = 1
                            else:
                                timestamp_dict[timestamp]['urls'][url] += 1
                    for timestamp, data in timestamp_dict.items():
                        if 'TimeInterval' in dimensions:
                            report.append({
                                'Id': id,
                                'Pid': 1,
                                'URL': None,
                                'SourceIP': None,
                                'TimeInterval': str(timestamp),
                                'Count': data['count']
                            })
                            id += 1
                        for url, url_count in data['urls'].items():
                            if 'URL' in dimensions:
                                report.append({
                                    'Id': id,
                                    'Pid': 2,
                                    'URL': url,
                                    'SourceIP': None,
                                    'TimeInterval': None,
                                    'Count': url_count
                                })
                                id += 1
            if (dimensions[0]=='TimeInterval' and dimensions[1]=='SourceIP'):
                for timestamp, stats in self.statistics5.items():
                    report.append({
                        'Id': id,
                        'Pid': None,
                        'URL': None,
                        'SourceIP': None,
                        'TimeInterval': str(timestamp),
                        'Count': len(stats)
                    })
                    id += 1
                    ip_dict = {}
                    for stat in stats:
                        ip, url = stat
                        if ip not in ip_dict:
                            ip_dict[ip] = {'count': 1, 'urls': {url: 1}}
                        else:
                            if url not in ip_dict[ip]['urls']:
                                ip_dict[ip]['count'] += 1
                                ip_dict[ip]['urls'][url] = 1
                            else:
                                ip_dict[ip]['urls'][url] += 1
                    for ip, data in ip_dict.items():
                        if 'SourceIP' in dimensions:
                            report.append({
                                'Id': id,
                                'Pid': 1,
                                'URL': None,
                                'SourceIP': ip,
                                'TimeInterval': None,
                                'Count': sum(data['urls'].values())
                            })
                            id += 1
                        for url, url_count in data['urls'].items():
                            if 'URL' in dimensions:
                                report.append({
                                    'Id': id,
                                    'Pid': 2,
                                    'URL': url,
                                    'SourceIP': None,
                                    'TimeInterval': None,
                                    'Count': url_count
                                })
                                id += 1
            if (dimensions[0]=='TimeInterval' and dimensions[1]=='URL'):
                for timestamp, stats in self.statistics6.items():
                    report.append({
                        'Id': id,
                        'Pid': None,
                        'URL': None,
                        'SourceIP': None,
                        'TimeInterval': str(timestamp),
                        'Count': len(stats)
                    })
                    id += 1
                    url_dict = {}
                    for stat in stats:
                        url, ip = stat
                        if url not in url_dict:
                            url_dict[url] = {'count': 1, 'ips': {ip: 1}}
                        else:
                            if ip not in url_dict[url]['ips']:
                                url_dict[url]['ips'][ip] = 1
                            else:
                                url_dict[url]['ips'][ip] += 1
                            url_dict[url]['count'] = sum(url_dict[url]['ips'].values())
                    for url, data in url_dict.items():
                        if 'URL' in dimensions:
                            report.append({
                                'Id': id,
                                'Pid': 1,
                                'URL': url,
                                'SourceIP': None,
                                'TimeInterval': None,
                                'Count': data['count']
                            })
                            id += 1
                        for ip, ip_count in data['ips'].items():
                            if 'SourceIP' in dimensions:
                                report.append({
                                    'Id': id,
                                    'Pid': 2,
                                    'URL': None,
                                    'SourceIP': ip,
                                    'TimeInterval': None,
                                    'Count': ip_count
                                })
                                id += 1
        # Форматирование и возврат отчета.
        formatted_report = self.format_report(report, dimensions)
        return formatted_report

    # Метод для форматирования отчета.
    def format_report(self, report, dimensions):
        max_length = max(len(item['URL']) for item in report if item['URL']) if 'URL' in dimensions else 0
        max_length = max(max_length, max(len(item['SourceIP']) for item in report if item['SourceIP'])) if 'SourceIP' in dimensions else max_length
        max_length = max(max_length, max(len(item['TimeInterval']) for item in report if item['TimeInterval'])) if 'TimeInterval' in dimensions else max_length
        formatted_report = ["\t\tДетализация".ljust(max_length) + "Количество переходов"]
        for item in report:
            line = "\t" * item['Pid'] if item['Pid'] is not None else ""
            for dimension in dimensions:
                if dimension == 'URL' and item['URL']:
                    line += f"{item['URL'].ljust(max_length)}\t"
                elif dimension == 'SourceIP' and item['SourceIP']:
                    line += f"{item['SourceIP'].ljust(max_length)}\t"
                elif dimension == 'TimeInterval' and item['TimeInterval']:
                    line += f"{item['TimeInterval'].ljust(max_length)}\t"
            if item['Pid'] == None:
                line += "\t" * 2
            elif item['Pid'] == 1:
                line += "\t" * 1
            elif item['Pid'] == 2:
                line += ""
            line += f"{item['Count']}"
            formatted_report.append(line)
        # Возврат отформатированного отчета в виде предварительно отформатированного текста.
        return '<pre>' + '\n'.join(formatted_report) + '</pre>'

# Создание экземпляра Flask-приложения.
app = Flask(__name__)
stats = Statistics() # Создание экземпляра класса Statistics.

# Маршрут для обработки POST-запросов на отправку статистики.
@app.route('/', methods=['POST'])
def post_statistics():
    # Получение данных из запроса.
    ip = request.json['ip']
    url = request.json['url']
    timestamp = request.json['timestamp']
    # Вызов метода для отправки статистики и возврат результата.
    return stats.post_statistics(ip, url, timestamp)

# Маршрут для обработки POST-запросов на создание отчета.
@app.route('/report', methods=['POST'])
def report():
    # Получение параметров из запроса.
    dimensions = request.json['Dimensions']
    # Вызов метода для создания отчета и возврат результата в формате JSON.
    return jsonify(stats.report(dimensions))

# Маршрут для обработки GET-запросов на получение отчета.
@app.route('/get_report', methods=['GET'])
def get_report():
    # Получение параметров из строки запроса.
    dimensions = request.args.get('dimensions').split(',')
    # Отправка POST-запроса на локальный сервер для получения отчета.
    response = requests.post('http://localhost:5001/report', json={"Dimensions": dimensions})
    # Возврат полученного отчета в формате JSON.
    return response.json()

if __name__ == '__main__':
    app.run(port=5001, debug=True)
==========================================================